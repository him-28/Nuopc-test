!-------------------------------------------------------------------------------
! COAMPS Grid-Search-Remapping Utilities Module (derived from WW3 w3gsrumd.ftn)
!-------------------------------------------------------------------------------
! CONFIGURATION IDENTIFICATION $HeadURL$
! CONFIGURATION IDENTIFICATION @(#)$Id$
!-------------------------------------------------------------------------------
#define FILENAME "COAMPS_Gsrumd.F90"


#define DIST_WITH_SINE
!/ =================================================================== /
      MODULE COAMPS_GSRUMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    30-Oct-2009 : Origination.                        ( version 3.14 )
!/    14-Jun-2010 : Fix for ACOS argument > 1 in W3DIST ( version 3.14 )
!/    12-Nov-2010 : Change T_NNS, W3NN*, W3SORT, W3ISRT to public.
!/                  Add W3GFIJ (public). Implement r4 & r8 interfaces.
!/                  Add subcell check for grid cell that includes a pole.
!/                  Change to number of search buckets based on
!/                  dimensions of input grid.           ( version 3.14 )
!/    01-Dec-2010 : Assign cells to buckets based on overlap. The
!/                  nearest-neighbor bucket search is removed (no longer
!/                  needed). Add support for tripole grids (JCLO).
!/                  Add W3GFCD (public). Some cleanup. Add ouput of
!/                  approximate memory usage.           ( version 3.14 )
!/    01-Dec-2010 : Add check for target point coincident with a cell
!/                  vertex in W3RMBL.  Change to error exit when unable
!/                  to determine local (i,j).           ( version 3.14 )
!/    06-Dec-2010 : Remove restriction on longitude range. Change ICLO
!/                  to integer and remove JCLO. Implement support for
!/                  r4 and r8 source grids.             ( version 3.14 )
!/    15-Jun-2012 : Fixed various format statements that gave compile
!/                  warnings with Intel compiler on NCEP R&D machine
!/                  zeus (H. L. Tolman)                 ( version 4.07 )
!/    DD-MMM-YYYY : Moved all record of changes from subroutines to
!/                  the top of the module and consolidate source code
!/                  for procedure interfaces            ( version 5.XX )
!/    DD-MMM-YYYY : Fix tripole grid y-index mapping and implement
!/                  additional index closure types.     ( version 5.XX )
!/    DD-MMM-YYYY : Generalize index bounds for source  ( version 5.XX )
!/    DD-MMM-YYYY : Add small non-zero tolerance to bounding box checks,
!/                  point coincidence checks and checks for points that
!/                  lie exactly on a cell side          ( version 5.XX )
!/    DD-MMM-YYYY : Add option to W3GFCL, W3GRMP, and W3GFIJ to allow
!/                  target outside of source grid       ( version 5.XX )
!/    DD-MMM-YYYY : Implement more accurate sin(d/2) equation in W3DIST
!/                  for computing angular distance      ( version 5.XX )
!/    DD-MMM-YYYY : Implement stereographic projection for remapping
!/                  from cells near a pole              ( version 5.XX )
!/    DD-MMM-YYYY : Add routine for computing metric and derivatives
!/                  for a curvilinear grid and routines for computing
!/                  gradient and divergence of fields defined on a
!/                  curvilinear grid                    ( version 5.XX )
!/
!  1. Purpose :
!
!     Search, regrid, and miscellaneous utilities (data structures and
!     associated methods) for logically rectangular grids.
!
!     The grid-search-utility (GSU) object can be used for rapid searching
!     of the associated grid to identify a grid cell that encloses a target
!     point and to compute interpolation weights.  The GSU object maintains
!     internal pointers to the associated grid coordinate arrays.  Rapid
!     searching is done using a bucket search algorithm.  The search buckets
!     are based on the bounding box for the associated grid and an optional
!     user defined approximate number of grid cells per search bucket.
!
!     Grid cells are identified by the cell's lower-left corner grid point.
!     The vertices (grid points) associated with a grid cell are assigned a
!     sequential index in a counterclockwise order beginning with the cell's
!     lower-left corner grid point.  That is, when moving from vertex 1 to
!     vertex 2 to vertex 3, etc., the grid cell interior is always to the left.
!     Note that though cell will be counterclockwise w.r.t. indices, this does 
!     not necessarily mean that the cell will be counterclockwise geographically,
!     specifically in situation of curvilinear grid.
!
!                  (x4,y4)               (x3,y3)
!                      _____________________
!                     /                    /
!                    /                    /
!                   /                    /
!                  /                    /
!                 /____________________/
!             (x1,y1)              (x2,y2)
!
!
!     There are two types of index space closure supported for lat/lon grids.
!
!       1) Simple closure: Grid is periodic in the i-index and wraps
!          at i=NX+1. In other words, (NX+1,j) => (1,j).
!
!       2) Tripole grid closure: Grid is periodic in the i-index and
!          and wraps at i=NX+1 and has closure at j=NY+1. In other words,
!          (NX+1,j<=NY) => (1,j) and (i,NY+1) => (NX-MOD(i-1,NX),NY).
!          The tripole grid closure requires that NX be even.
!
!
!     A simple interpolation example:
!
!          -----------------------------------------------------------
!          ! Define data
!          TYPE(T_GSU) :: GSU
!          INTEGER :: NX, NY                  !source grid dimensions
!          REAL, POINTER :: XS(:,:), YS(:,:)  !source grid coordinates
!          REAL :: FS(:,:)                    !source field
!          INTEGER :: NT                      !number of target points
!          REAL :: XT(NT), YT(NT), FT(NT)     !target coordinates and field
!          INTEGER :: IS(4), JS(4)            !interpolation points
!          REAL :: RW(4)                      !interpolation weights
!
!          ! Setup source grid and field and target points
!          < ... >
!
!          ! Create grid-search-utility object for source grid
!          GSU = W3GSUC( .TRUE., .FALSE., ICLO_NONE, XS, YS )
!
!          ! Interpolate source field to target points
!          DO K=1,NT
!            FT(K) = 0
!            IF ( W3GRMP( GSU, XT(K), YT(K), IS, JS, RW ) ) THEN
!                DO L=1,4
!                  FT(K) = FT(K) + RW(L)*FS(IS(L),JS(L))
!                  END DO
!              END IF
!            END DO
!
!          ! Destroy grid-search-utility object
!          CALL W3GSUD( GSU )
!          -----------------------------------------------------------
!
!  2. Variables and types :
!
!     All module variables and types are scoped private by default.
!     The private module variables and types are not listed in this section.
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!      MSKC_NONE I.P.  Public   Named constant identifying a non-masked
!                               enclosing grid cell
!      MSKC_PART I.P.  Public   Named constant identifying a partially
!                               masked enclosing grid cell
!      MSKC_FULL I.P.  Public   Named constant identifying a fully
!                               masked enclosing grid cell
!      ICLO_NONE I.P.  Public   Named constant identifying a grid with
!                               no closure in index space
!      ICLO_SMPL I.P.  Public   Synonym for ICLO_GRDI
!      ICLO_GRDI I.P.  Public   Named constant identifying a grid with
!                               closure in I-index: (NX+1,j) => (1,j)
!      ICLO_GRDJ I.P.  Public   Named constant identifying a grid with
!                               closure in J-index: (i,NY+1) => (i,1)
!      ICLO_TRDL I.P.  Public   Named constant identifying a grid with
!                               toroidal closure: (NX+1,j) => (1,j) and
!                                                 (i,NY+1) => (i,1)
!      ICLO_TRPL I.P.  Public   Named constant identifying a grid with
!                               tripole closure: (NX+1,j<=NY) => (1,j)
!                               and (i,NY+1) => (NX-MOD(i-1,NX),NY)
!      T_GSU     TYPE  Public   Grid-search-utility type (opaque)
!      T_NNS     TYPE  Public   Nearest-neighbor grid-point search type
!     ----------------------------------------------------------------
!
!  3. Subroutines and functions :
!
!     All module subroutines and functions are scoped private by default.
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!      W3GSUC    Func. Public   Create grid-search-utility object.
!      W3GSUD    Subr. Public   Destroy grid-search-utility object.
!      W3GSUP    Subr. Public   Print grid-search-utility object to stdout.
!      W3GFCL    Func. Public   Find grid cell that encloses target point (bucket search).
!      W3GFCD    Func. Public   Find grid cell that encloses target point (direct search).
!      W3GFPT    Func. Public   Find grid point that is closest to target point.
!      W3GFIJ    Func. Public   Compute coord of target point in source grid index space
!      W3GRMP    Func. Public   Compute interpolation coeff. from grid.
!      W3CKCL    Func. Public   Check if point lies within grid cell.
!      W3RMBL    Subr. Public   Compute bilinear interpolation coeff. from cell.
!      W3CGDM    Func. Public   Compute curvilinear grid derivatives and metric
!      W3GRD0    Func. Public   Compute curvilinear gradient of scalar field
!      W3DIV1    Func. Public   Compute curvilinear divergence of a vector field
!      W3DIV2    Func. Public   Compute curvilinear divergence of a tensor field
!      W3DIST    Func. Public   Compute distance between two points.
!      W3SPLX    Func. Public   Compute Cartesian coord using stereographic projection
!      W3SPXL    Func. Public   Compute (lon,lat) coord using stereographic projection
!      W3TRLL    Func. Public   Compute (lon,lat) in rotated coordinate system
!      W3LLAZ    Func. Public   Compute azimuth for pair of (lon,lat) points
!      W3FDWT    Func. Public   Compute finite-difference weights.
!      W3NNSC    Func. Public   Create nearest-neighbor-search object.
!      W3NNSD    Subr. Public   Destroy nearest-neighbor-search object.
!      W3NNSP    Subr. Public   Print nearest-neighbor-search object to stdout.
!      W3SORT    Subr. Public   Sort input arrays in increasing order.
!      W3ISRT    Subr. Public   Insert data into array.
!      W3INAN    Func. Public   Check if input is infinite or NaN.
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!      EXTCDE    Subr. W3SERVMD Abort program with exit code.
!     ----------------------------------------------------------------
!
!  5. Remarks :
!
!     - The GSU object is an "opaque" object.  This means that the
!       internals of the object are not accessible outside this module.
!     - The burden is upon the user to invoke the destroy method when
!       finished with a GSU object.  If created GSU objects are
!       not properly destroyed, then memory leaks may be introduced.
!
!  6. Switches :
!
!     !/S    Enable subroutine tracing.
!
!  7. Source code :
!
!/ =================================================================== /
!/
!/ Use associated modules
!/
!     USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!/
!/ Specify default data typing
!/
      IMPLICIT NONE
!/
!/ Specify default accessibility
!/
      PRIVATE
!/
!/ Public module methods
!/
      PUBLIC W3GSUC
      PUBLIC W3GSUD
      PUBLIC W3GSUP
      PUBLIC W3GFCL
      PUBLIC W3GFCD
      PUBLIC W3GFPT
      PUBLIC W3GFIJ
      PUBLIC W3GRMP
      PUBLIC W3CKCL
      PUBLIC W3RMBL
      PUBLIC W3CGDM
      PUBLIC W3GRD0
      PUBLIC W3DIV1
      PUBLIC W3DIV2
      PUBLIC W3DIST
      PUBLIC W3SPLX
      PUBLIC W3SPXL
      PUBLIC W3TRLL
      PUBLIC W3LLAZ
      PUBLIC W3FDWT
      PUBLIC W3NNSC
      PUBLIC W3NNSD
      PUBLIC W3NNSP
      PUBLIC W3SORT
      PUBLIC W3ISRT
      PUBLIC W3INAN
!/
!/ Public return codes
!/
      INTEGER, PARAMETER, PUBLIC :: MSKC_NONE = 0
      INTEGER, PARAMETER, PUBLIC :: MSKC_PART = 1
      INTEGER, PARAMETER, PUBLIC :: MSKC_FULL = 2
!/
!/ Public index closure types (for lat/lon grids only)
!/   ICLO_NONE : no closure in index space
!/   ICLO_SMPL : synonym for ICLO_GRDI
!/   ICLO_GRDI : closure in i-index at i=NX+1: (NX+1,j) => (1,j)
!/   ICLO_GRDJ : closure in j-index at j=NY+1: (i,NY+1) => (i,1)
!/   ICLO_TRDL : toroidal grid closure: (NX+1,j) => (1,j) and
!/                                      (i,NY+1) => (i,1)
!/   ICLO_TRPL : tripole grid closure: (NX+1,j<=NY) => (1,j) and
!/                                     (i,NY+1) => (NX-MOD(i-1,NX),NY)
!/
!/   Note that simple i-index closure types are set to multiples of 2.
!/   Note that simple j-index closure types are set to multiples of 3.
!/   These settings are used in the GSU methods to simplify checking.
!/
      INTEGER, PARAMETER, PUBLIC :: ICLO_NONE = -1
      INTEGER, PARAMETER, PUBLIC :: ICLO_SMPL = 2
      INTEGER, PARAMETER, PUBLIC :: ICLO_GRDI = ICLO_SMPL
      INTEGER, PARAMETER, PUBLIC :: ICLO_GRDJ = 3
      INTEGER, PARAMETER, PUBLIC :: ICLO_TRDL = 6
      INTEGER, PARAMETER, PUBLIC :: ICLO_TRPL = 8
!/
!/ Public grid-search-utility type
!/ This is an opaque type -- that is, it's internals are private and only
!/ accessible to subroutines in this module where the type is declared.
!/
      TYPE, PUBLIC :: T_GSU
        PRIVATE
        TYPE(CLASS_GSU), POINTER :: PTR => NULL()
      END TYPE T_GSU
!/
!/ Private grid-search-utility class
!/
      TYPE :: CLASS_GSU
        LOGICAL :: IJG  ! grid array ordering flag: T = (NX,NY), F = (NY,NX)
        LOGICAL :: LLG  ! spherical coordinate flag of associated grid
        INTEGER :: ICLO ! parameter indicating type of index space closure
                        ! this flag must be set by the user
        LOGICAL :: LCLO ! flag indicating longitudinal periodicity
                        ! this flag is calculated internally
                        ! LLG & ICLO != ICLO_NONE => LCLO = T
        LOGICAL :: L360 ! flag indicating longitude range:
                        !   T = [0:360],  F = [-180:180]
        INTEGER :: GKIND  ! kind (precision: 4 or 8) of associated grid
        INTEGER :: LBX, LBY ! lower-bounds of associated grid
        INTEGER :: UBX, UBY ! upper-bounds of associated grid
        INTEGER :: NX, NY   ! dimensions of associated grid
        REAL(4), POINTER :: XG4(:,:), YG4(:,:) ! coordinates of associated grid (r4)
        REAL(8), POINTER :: XG8(:,:), YG8(:,:) ! coordinates of associated grid (r8)
        TYPE(T_NNS), POINTER :: NNP  ! nearest-neighbor point search indices object
        INTEGER :: NBX, NBY  ! number of buckets in each spatial direction
        REAL(8) :: DXB, DYB  ! spatial extent of each search bucket
        REAL(8) :: XMIN, YMIN, XMAX, YMAX ! bounding box of search domain
        TYPE(T_BKT), POINTER :: B(:,:) ! array of search buckets
        TYPE(T_NNS), POINTER :: NNB  ! nearest-neighbor bucket search indices object
      END TYPE CLASS_GSU
!/
!/ Private search bucket type
!/
      TYPE :: T_BKT
        INTEGER :: N  ! number of cells in bucket
        INTEGER, POINTER :: I(:)  ! i-index of cell c
        INTEGER, POINTER :: J(:)  ! j-index of cell c
      END TYPE T_BKT
!/
!/ Public nearest-neighbor grid-point search type
!/
      TYPE, PUBLIC :: T_NNS
        INTEGER :: NLVL  ! number of nnbr levels
        INTEGER :: NNBR  ! total number of nnbr's
        INTEGER, POINTER :: N1(:)  ! starting nearest-nbr loop index for level l
        INTEGER, POINTER :: N2(:)  ! ending nearest-nbr loop index for level l
        INTEGER, POINTER :: DI(:)  ! i-index delta for nearest-nbr n
        INTEGER, POINTER :: DJ(:)  ! j-index delta for nearest-nbr n
      END TYPE T_NNS
!/
!/ Private module parameters
!/
      REAL(8), PARAMETER :: PI = 3.14159265358979323846D0
      REAL(8), PARAMETER :: PI2 = 2D0*PI
      REAL(8), PARAMETER :: PI3H = 3D0*PI/2D0
      REAL(8), PARAMETER :: PIO2 = PI/2D0
      REAL(8), PARAMETER :: PIO4 = PI/4D0
      REAL(8), PARAMETER :: D2R = PI/180D0
      REAL(8), PARAMETER :: R2D = 1D0/D2R
      REAL(8), PARAMETER :: D360 = 360D0
      REAL(8), PARAMETER :: D270 = 270D0
      REAL(8), PARAMETER :: D180 = 180D0
      REAL(8), PARAMETER :: D90  =  90D0
      REAL(8), PARAMETER :: ZERO = 0.0D0
      REAL(8), PARAMETER :: HALF = 0.5D0
      REAL(8), PARAMETER :: ONE  = 1.0D0
      REAL(8), PARAMETER :: TWO  = 2.0D0
      REAL(8), PARAMETER :: FOUR = 4.0D0
      REAL(8), PARAMETER :: REARTH = 4.D7/PI2
      REAL(8), PARAMETER :: D2M  = REARTH*D2R
      REAL(8), PARAMETER :: M2D  = 1D0/D2M
!     Default small non-zero tolerance used to check if
!     target point is in domain and for point coincidence.
      REAL(8), PARAMETER :: EPS_DEFAULT  = 1.0D-6
!     Distance (deg) from pole to consider a cell "near the pole"
      REAL(8), PARAMETER :: NEAR_POLE = 10.0D0
!     Default number of grid cells (in each direction) per search bucket.
      INTEGER, PARAMETER :: NCB_DEFAULT = 10
!     Default maximum number of nearest-neighbor grid point search levels.
      INTEGER, PARAMETER :: NNP_DEFAULT = 2
!     Max number of non-empty levels for bucket search when target point
!     is outside source domain
      INTEGER, PARAMETER :: MAX_FNCL_LEVEL = 3
!     Default finite-difference order
      INTEGER, PARAMETER :: NFD_DEFAULT = 4
!/
!/ Module Interfaces
!/
      INTERFACE W3GSUC
        MODULE PROCEDURE W3GSUC_R4
        MODULE PROCEDURE W3GSUC_R8
      END INTERFACE W3GSUC
      INTERFACE W3GFCL
        MODULE PROCEDURE W3GFCL_R4
        MODULE PROCEDURE W3GFCL_R8
      END INTERFACE W3GFCL
      INTERFACE W3GFCD
        MODULE PROCEDURE W3GFCD_R4
        MODULE PROCEDURE W3GFCD_R8
      END INTERFACE W3GFCD
      INTERFACE W3GFPT
        MODULE PROCEDURE W3GFPT_R4
        MODULE PROCEDURE W3GFPT_R8
      END INTERFACE W3GFPT
      INTERFACE W3GFIJ
        MODULE PROCEDURE W3GFIJ_R4
        MODULE PROCEDURE W3GFIJ_R8
      END INTERFACE W3GFIJ
      INTERFACE W3GRMP
        MODULE PROCEDURE W3GRMP_R4
        MODULE PROCEDURE W3GRMP_R8
      END INTERFACE W3GRMP
      INTERFACE W3RMBL
        MODULE PROCEDURE W3RMBL_R4
        MODULE PROCEDURE W3RMBL_R8
      END INTERFACE W3RMBL
      INTERFACE W3CGDM
        MODULE PROCEDURE W3CGDM_R4
        MODULE PROCEDURE W3CGDM_R8
      END INTERFACE W3CGDM
      INTERFACE W3GRD0
        MODULE PROCEDURE W3GRD0_R4
        MODULE PROCEDURE W3GRD0_R8
      END INTERFACE W3GRD0
      INTERFACE W3DIV1
        MODULE PROCEDURE W3DIV1_R4
        MODULE PROCEDURE W3DIV1_R8
      END INTERFACE W3DIV1
      INTERFACE W3DIV2
        MODULE PROCEDURE W3DIV2_R4
        MODULE PROCEDURE W3DIV2_R8
      END INTERFACE W3DIV2
      INTERFACE W3DIST
        MODULE PROCEDURE W3DIST_R4
        MODULE PROCEDURE W3DIST_R8
      END INTERFACE W3DIST
      INTERFACE W3SPLX
        MODULE PROCEDURE W3SPLX_0D_R4
        MODULE PROCEDURE W3SPLX_0D_R8
        MODULE PROCEDURE W3SPLX_1D_R4
        MODULE PROCEDURE W3SPLX_1D_R8
        MODULE PROCEDURE W3SPLX_2D_R4
        MODULE PROCEDURE W3SPLX_2D_R8
      END INTERFACE W3SPLX
      INTERFACE W3SPXL
        MODULE PROCEDURE W3SPXL_0D_R4
        MODULE PROCEDURE W3SPXL_0D_R8
        MODULE PROCEDURE W3SPXL_1D_R4
        MODULE PROCEDURE W3SPXL_1D_R8
        MODULE PROCEDURE W3SPXL_2D_R4
        MODULE PROCEDURE W3SPXL_2D_R8
      END INTERFACE W3SPXL
      INTERFACE W3TRLL
        MODULE PROCEDURE W3TRLL_0D_R4
        MODULE PROCEDURE W3TRLL_0D_R8
        MODULE PROCEDURE W3TRLL_1D_R4
        MODULE PROCEDURE W3TRLL_1D_R8
        MODULE PROCEDURE W3TRLL_2D_R4
        MODULE PROCEDURE W3TRLL_2D_R8
      END INTERFACE W3TRLL
      INTERFACE W3LLAZ
        MODULE PROCEDURE W3LLAZ_R4
        MODULE PROCEDURE W3LLAZ_R8
      END INTERFACE W3LLAZ
      INTERFACE W3FDWT
        MODULE PROCEDURE W3FDWT_R4
        MODULE PROCEDURE W3FDWT_R8
      END INTERFACE W3FDWT
      INTERFACE W3CKCL
        MODULE PROCEDURE W3CKCL_R4
        MODULE PROCEDURE W3CKCL_R8
      END INTERFACE W3CKCL
      INTERFACE W3SORT
        MODULE PROCEDURE W3SORT_R4
        MODULE PROCEDURE W3SORT_R8
      END INTERFACE W3SORT
      INTERFACE W3ISRT
        MODULE PROCEDURE W3ISRT_R4
        MODULE PROCEDURE W3ISRT_R8
      END INTERFACE W3ISRT
      INTERFACE W3INAN
        MODULE PROCEDURE W3INAN_R4
        MODULE PROCEDURE W3INAN_R8
      END INTERFACE W3INAN

!/
      CONTAINS
!/
!/ =================================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GSUC( IJG, LLG, ICLO, XG, YG, NCB, NNP, DEBUG ) &
!/    RESULT(GSU)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Create grid-search-utility (GSU) object for a logically rectangular
!     grid defined by the input coordinates.
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       GSU     Type   O   Created grid-search-utility object.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       IJG     Log.   I   Logical flag indicating ordering of input
!                          coord. arrays: T = (NX,NY) and F = (NY,NX).
!       LLG     Log.   I   Logical flag indicating the coordinate system:
!                          T = spherical lat/lon (degrees) and F = Cartesian.
!       ICLO    Int.   I   Parameter indicating type of index space closure
!       XG      R.A.   I   Pointer to array of x-coordinates of input grid.
!       YG      R.A.   I   Pointer to array of y-coordinates of input grid.
!       NCB     Int.   I   OPTIONAL (approximate) number of cells (in each
!                          direction) per search bucket. (default is NCB_DEFAULT)
!                          NCB >= 1 is required.  NCB = 1 gives most efficient
!                          searching, but uses more memory. Increasing NCB leads
!                          to fewer buckets (less memory) but slower searching.
!       NNP     Int.   I   OPTIONAL maximum number of nearest-neighbor grid
!                          point search levels. (default is NNP_DEFAULT)
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on correct coordinate system with global grid.
!     - Check on association of input grid coordinate array pointers.
!
!  7. Remarks :
!
!     - LCLO is calculated internally.
!     - LLG & ICLO != ICLO_NONE => LCLO = T.
!     - Periodic Cartesian grids are not allowed.
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Allocate object and set grid related data and pointers
!      3.  Create nearest-neighbor point search object
!      4.  Construct bucket search "object"
!      5.  Set return parameter
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!     !/T8   Enables debugging flag.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GSUC_R4( IJG, LLG, ICLO, XG, YG, NCB, NNP, DEBUG ) &
      RESULT(GSU)
!     Single precision interface
      TYPE(T_GSU)         :: GSU
      LOGICAL, INTENT(IN) :: IJG
      LOGICAL, INTENT(IN) :: LLG
      INTEGER, INTENT(IN) :: ICLO
      REAL(4), POINTER    :: XG(:,:), YG(:,:)
      INTEGER, INTENT(IN), OPTIONAL :: NCB
      INTEGER, INTENT(IN), OPTIONAL :: NNP
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GSUC_R4')
!
      IF ( .NOT.ASSOCIATED(XG) .OR. .NOT.ASSOCIATED(YG) ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC_R4 ERROR -- ', &
          'input grid coordinate array pointers are not associated'
          CALL EXTCDE (1)
        END IF

      GSU = GSU_CREATE( IJG, LLG, ICLO, XG4=XG, YG4=YG, &
                        NCB=NCB, NNP=NNP, DEBUG=DEBUG)

      END FUNCTION W3GSUC_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GSUC_R8( IJG, LLG, ICLO, XG, YG, NCB, NNP, DEBUG ) &
      RESULT(GSU)
!     Single precision interface
      TYPE(T_GSU)         :: GSU
      LOGICAL, INTENT(IN) :: IJG
      LOGICAL, INTENT(IN) :: LLG
      INTEGER, INTENT(IN) :: ICLO
      REAL(8), POINTER    :: XG(:,:), YG(:,:)
      INTEGER, INTENT(IN), OPTIONAL :: NCB
      INTEGER, INTENT(IN), OPTIONAL :: NNP
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GSUC_R8')
!
      IF ( .NOT.ASSOCIATED(XG) .OR. .NOT.ASSOCIATED(YG) ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC_R8 ERROR -- ', &
          'input grid coordinate array pointers are not associated'
          CALL EXTCDE (1)
        END IF

      GSU = GSU_CREATE( IJG, LLG, ICLO, XG8=XG, YG8=YG, &
                        NCB=NCB, NNP=NNP, DEBUG=DEBUG)

      END FUNCTION W3GSUC_R8
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION GSU_CREATE( IJG, LLG, ICLO, XG4, YG4, XG8, YG8, &
                           NCB, NNP, DEBUG ) RESULT(GSU)
!     *** INTERNAL SUBROUTINE ***
      TYPE(T_GSU)         :: GSU
      LOGICAL, INTENT(IN) :: IJG
      LOGICAL, INTENT(IN) :: LLG
      INTEGER, INTENT(IN) :: ICLO
      REAL(4), POINTER, OPTIONAL    :: XG4(:,:)
      REAL(4), POINTER, OPTIONAL    :: YG4(:,:)
      REAL(8), POINTER, OPTIONAL    :: XG8(:,:)
      REAL(8), POINTER, OPTIONAL    :: YG8(:,:)
      INTEGER, INTENT(IN), OPTIONAL :: NCB
      INTEGER, INTENT(IN), OPTIONAL :: NNP
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      TYPE(CLASS_GSU), POINTER :: PTR
      LOGICAL :: TYPE_R4, TYPE_R8
      LOGICAL :: LDBG, LBC,LPL, LNPL, LSPL
      INTEGER :: LBX, LBY, UBX, UBY, NX, NY
      INTEGER :: LXC, LYC, UXC, UYC
      INTEGER :: I, J, K, L, N, IC(4), JC(4), IB, JB
      INTEGER :: NS, IB1(2), IB2(2), JB1(2), JB2(2), IBC(4), JBC(4)
      INTEGER :: ISTEP, ISTAT
      REAL(8) :: X, Y, XC(4), YC(4)
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GSUC')
! -------------------------------------------------------------------- /
! 1.  Test input
!
      TYPE_R4 = PRESENT(XG4).AND.PRESENT(YG4)
      TYPE_R8 = PRESENT(XG8).AND.PRESENT(YG8)
      IF ( .NOT.TYPE_R4.AND..NOT.TYPE_R8 ) THEN
          WRITE(0,'(/1A,1A,1I2/)') 'W3GSUC ERROR -- ', &
          'no input grid pointers specified'
          CALL EXTCDE (1)
        END IF

      IF (IJG) THEN
          IF (TYPE_R4) THEN
              LBX = LBOUND(XG4,1)
              LBY = LBOUND(XG4,2)
              UBX = UBOUND(XG4,1)
              UBY = UBOUND(XG4,2)
            ELSE
              LBX = LBOUND(XG8,1)
              LBY = LBOUND(XG8,2)
              UBX = UBOUND(XG8,1)
              UBY = UBOUND(XG8,2)
            END IF
        ELSE
          IF (TYPE_R4) THEN
              LBX = LBOUND(XG4,2)
              LBY = LBOUND(XG4,1)
              UBX = UBOUND(XG4,2)
              UBY = UBOUND(XG4,1)
            ELSE
              LBX = LBOUND(XG8,2)
              LBY = LBOUND(XG8,1)
              UBX = UBOUND(XG8,2)
              UBY = UBOUND(XG8,1)
            END IF
        END IF
      NX = UBX - LBX + 1
      NY = UBY - LBY + 1

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3GSUC ERROR -- ', &
            'unsupported ICLO: ',ICLO
            CALL EXTCDE (1)
        END SELECT

      IF ( ICLO.NE.ICLO_NONE .AND. (LBX.NE.1 .OR. LBY.NE.1) ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC ERROR -- ', &
          'index space closure with grid index lower-bounds'// &
          ' != 1 is not supported'
          CALL EXTCDE (1)
        END IF

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NX,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC ERROR -- ', &
          'tripole grid closure requires NX even'
          CALL EXTCDE (1)
        END IF

      IF ( PRESENT(NCB) ) THEN
          IF ( NCB .LE. 0 ) THEN
              WRITE(0,'(/1A,1A/)') 'W3GSUC ERROR -- ', &
              'NCB must be greater than zero'
              CALL EXTCDE (1)
            END IF
        END IF
!
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!/T8      LDBG=.TRUE.
!
! -------------------------------------------------------------------- /
! 2.  Allocate object and set grid related data and pointers
!
      ALLOCATE(PTR, STAT=ISTAT)
      IF ( ISTAT .NE. 0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC ERROR -- ', &
          'gsu object allocation failed'
          CALL EXTCDE (ISTAT)
        END IF
      PTR%IJG = IJG
      PTR%LLG = LLG
      PTR%ICLO = ICLO
      PTR%LBX = LBX
      PTR%LBY = LBY
      PTR%UBX = UBX
      PTR%UBY = UBY
      PTR%NX = NX
      PTR%NY = NY
      IF (TYPE_R4) THEN
          PTR%XG4 => XG4
          PTR%YG4 => YG4
          PTR%GKIND = 4
        ELSE
          PTR%XG8 => XG8
          PTR%YG8 => YG8
          PTR%GKIND = 8
        END IF
!
! -------------------------------------------------------------------- /
! 3.  Create nearest-neighbor point search object
!
      IF ( PRESENT(NNP) ) THEN
          PTR%NNP => W3NNSC(NNP)
        ELSE
          PTR%NNP => W3NNSC(NNP_DEFAULT)
        END IF
!
! -------------------------------------------------------------------- /
! 4.  Construct bucket search "object"
!
!-----number of cells
      LXC = LBX;  LYC = LBY;
      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE )
            UXC = UBX-1;  UYC = UBY-1;
          CASE ( ICLO_GRDI )
            UXC = UBX;    UYC = UBY-1;
          CASE ( ICLO_GRDJ )
            UXC = UBX-1;  UYC = UBY;
          CASE ( ICLO_TRDL )
            UXC = UBX;    UYC = UBY;
          CASE ( ICLO_TRPL )
            UXC = UBX;    UYC = UBY;
        END SELECT
!
!-----initialize longitudinal periodicity flag (LCLO)
      IF ( LLG .AND. ICLO.NE.ICLO_NONE ) THEN
          PTR%LCLO = .TRUE.
        ELSE
          PTR%LCLO = .FALSE.
        END IF
!
!-----check existence of longitudinal branch cut
!-----check if source grid includes poles
      IF ( LDBG ) THEN
          WRITE(*,'(/A)') 'W3GSUC - check source grid'
        END IF
      LNPL = .FALSE.
      LSPL = .FALSE.
      DO I=LXC,UXC
          DO J=LYC,UYC
!-------------create list of cell vertices
              IC(1) = I  ;  JC(1) = J  ;
              IC(2) = I+1;  JC(2) = J  ;
              IC(3) = I+1;  JC(3) = J+1;
              IC(4) = I  ;  JC(4) = J+1;
              DO L=1,4
!-----------------i-closure
                  IF ( MOD(ICLO,2).EQ.0 ) THEN
                      IF ( IC(L) .LT. LBX ) IC(L) = IC(L) + NX
                      IF ( IC(L) .GT. UBX ) IC(L) = IC(L) - NX
                    END IF
!-----------------j-closure
                  IF ( MOD(ICLO,3).EQ.0 ) THEN
                      IF ( JC(L) .LT. LBY ) JC(L) = JC(L) + NY
                      IF ( JC(L) .GT. UBY ) JC(L) = JC(L) - NY
                    END IF
                  IF ( ICLO.EQ.ICLO_TRPL ) THEN
                      IF ( JC(L) .GT. UBY ) THEN
                          JC(L) = UBY
                          IC(L) = NX - MOD(IC(L)-1,NX)
                        END IF
                    END IF
!-----------------copy cell vertex coordinates into local variables
                  IF ( IJG ) THEN
                      IF (TYPE_R4) THEN
                          XC(L) = XG4(IC(L),JC(L))
                          YC(L) = YG4(IC(L),JC(L))
                        ELSE
                          XC(L) = XG8(IC(L),JC(L))
                          YC(L) = YG8(IC(L),JC(L))
                        END IF
                    ELSE
                      IF (TYPE_R4) THEN
                          XC(L) = XG4(JC(L),IC(L))
                          YC(L) = YG4(JC(L),IC(L))
                        ELSE
                          XC(L) = XG8(JC(L),IC(L))
                          YC(L) = YG8(JC(L),IC(L))
                        END IF
                    END IF
                END DO !L
!-------------check if cell includes a pole or branch cut
              LPL = .FALSE.
              LBC = .FALSE.
              IF ( LLG ) THEN
!-----------------count longitudinal branch cut crossings
                  N = 0
                  DO L=1,4
                      K = MOD(L,4)+1
                      IF ( ABS(XC(K)-XC(L)) .GT. D180 ) N = N + 1
                    END DO
!-----------------multiple longitudinal branch cut crossing => cell includes branch cut
                  LBC = N.GT.1
                  IF ( LBC .AND. LDBG ) &
                  WRITE(*,'(A,8I6)') &
                  'W3GSUC -- cell includes branch cut:',IC(:),JC(:)
!-----------------single longitudinal branch cut crossing
!                 or single vertex at 90 degrees => cell includes pole
                  LPL = N.EQ.1 .OR. COUNT(ABS(YC).EQ.D90).EQ.1
                  IF ( LPL.AND.MINVAL(YC).GT.ZERO ) THEN
                      IF ( LDBG ) &
                      WRITE(*,'(A,8I6)') &
                      'W3GSUC -- cell includes N-pole:',IC(:),JC(:)
                      LNPL = .TRUE.
                    END IF
                  IF ( LPL.AND.MAXVAL(YC).LT.ZERO ) THEN
                      IF ( LDBG ) &
                      WRITE(*,'(A,8I6)') &
                      'W3GSUC -- cell includes S-pole:',IC(:),JC(:)
                      LSPL = .TRUE.
                    END IF
!-----------------longitudinal branch cut crossing => longitudinal closure
                  IF ( N.GT.0 ) PTR%LCLO = .TRUE.
                END IF !LLG
            END DO !J
        END DO !I
!
!-----compute domain for search buckets
!     if longitudinal periodicity, then force domain in x to [0:360]
!     if grid includes north pole, then set ymax =  90 degrees
!     if grid includes south pole, then set ymin = -90 degrees
      IF (TYPE_R4) THEN
          PTR%XMIN = MINVAL(XG4);  PTR%XMAX = MAXVAL(XG4);
          PTR%YMIN = MINVAL(YG4);  PTR%YMAX = MAXVAL(YG4);
        ELSE
          PTR%XMIN = MINVAL(XG8);  PTR%XMAX = MAXVAL(XG8);
          PTR%YMIN = MINVAL(YG8);  PTR%YMAX = MAXVAL(YG8);
        END IF
      IF ( PTR%LCLO ) THEN
          PTR%XMIN =  ZERO;  PTR%XMAX = D360;
        END IF
      IF ( LSPL ) PTR%YMIN = -D90
      IF ( LNPL ) PTR%YMAX =  D90
      PTR%L360 = PTR%XMIN.GE.ZERO
!
!-----compute number of search buckets and bucket size
      IF ( PRESENT(NCB) ) THEN
          PTR%NBX = MAX(1,NX/NCB)
          PTR%NBY = MAX(1,NY/NCB)
        ELSE
          PTR%NBX = MAX(1,NX/NCB_DEFAULT)
          PTR%NBY = MAX(1,NY/NCB_DEFAULT)
        END IF
      PTR%DXB = (PTR%XMAX-PTR%XMIN)/REAL(PTR%NBX)
      PTR%DYB = (PTR%YMAX-PTR%YMIN)/REAL(PTR%NBY)
!
!-----print debug info
      IF ( LDBG ) THEN
          WRITE(*,'(/A,1I2,1L2,1I2)') 'W3GSUC - ICLO,LCLO,GKIND: ', &
          PTR%ICLO,PTR%LCLO,PTR%GKIND
          WRITE(*,'(A,4E24.16)') 'W3GSUC - grid search domain:', &
          PTR%XMIN,PTR%YMIN,PTR%XMAX,PTR%YMAX
          WRITE(*,'(A,2I6)') 'W3GSUC - number of search buckets:', &
          PTR%NBX,PTR%NBY
          WRITE(*,'(A,2E24.16)') 'W3GSUC - search bucket size:', &
          PTR%DXB,PTR%DYB
        END IF
!
!-----allocate array of search buckets
      ALLOCATE(PTR%B(PTR%NBY,PTR%NBX),STAT=ISTAT)
      IF ( ISTAT .NE. 0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUC ERROR -- ', &
          'search bucket array allocation failed'
          CALL EXTCDE (ISTAT)
        END IF
!
!-----BEGIN ISTEP_LOOP
!     first step: compute number of cells in each bucket
!     second step: allocate buckets and assign cells to buckets
      ISTEP_LOOP: DO ISTEP=1,2
!
!-----allocate search bucket cell lists
      IF ( ISTEP .EQ. 2 ) THEN
      DO IB=1,PTR%NBX
          DO JB=1,PTR%NBY
              NULLIFY(PTR%B(JB,IB)%I)
              NULLIFY(PTR%B(JB,IB)%J)
              IF ( PTR%B(JB,IB)%N .GT. 0 ) THEN
                  ALLOCATE(PTR%B(JB,IB)%I(PTR%B(JB,IB)%N),STAT=ISTAT)
                  IF ( ISTAT .NE. 0 ) THEN
                      WRITE(0,'(/1A,2A,3I6/)') 'W3GSUC ERROR -- ', &
                      'search bucket cell-i list allocation failed -- ', &
                      'bucket: ',IB,JB,N
                      CALL EXTCDE (ISTAT)
                    END IF
                  ALLOCATE(PTR%B(JB,IB)%J(PTR%B(JB,IB)%N),STAT=ISTAT)
                  IF ( ISTAT .NE. 0 ) THEN
                      WRITE(0,'(/1A,2A,3I6/)') 'W3GSUC ERROR -- ', &
                      'search bucket cell-j list allocation failed -- ', &
                      'bucket: ',IB,JB,N
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
            END DO
        END DO
      END IF !ISTEP.EQ.2
!
!-----build search bucket cell lists
      PTR%B(:,:)%N = 0
      DO I=LXC,UXC
          DO J=LYC,UYC
              IF ( ICLO.EQ.ICLO_TRPL ) THEN
                  IF ( J.EQ.UYC .AND. I.GT.NX/2+1 ) CYCLE
                ENDIF
!-------------create list of cell vertices
              IC(1) = I  ;  JC(1) = J  ;
              IC(2) = I+1;  JC(2) = J  ;
              IC(3) = I+1;  JC(3) = J+1;
              IC(4) = I  ;  JC(4) = J+1;
              DO L=1,4
!-----------------i-closure
                  IF ( MOD(ICLO,2).EQ.0 ) THEN
                      IF ( IC(L) .LT. LBX ) IC(L) = IC(L) + NX
                      IF ( IC(L) .GT. UBX ) IC(L) = IC(L) - NX
                    END IF
!-----------------j-closure
                  IF ( MOD(ICLO,3).EQ.0 ) THEN
                      IF ( JC(L) .LT. LBY ) JC(L) = JC(L) + NY
                      IF ( JC(L) .GT. UBY ) JC(L) = JC(L) - NY
                    END IF
                  IF ( ICLO.EQ.ICLO_TRPL ) THEN
                      IF ( JC(L) .GT. UBY ) THEN
                          JC(L) = UBY
                          IC(L) = NX - MOD(IC(L)-1,NX)
                        END IF
                    END IF
!-----------------copy cell vertex coordinates into local variables
                  IF ( IJG ) THEN
                      IF (TYPE_R4) THEN
                          XC(L) = XG4(IC(L),JC(L))
                          YC(L) = YG4(IC(L),JC(L))
                        ELSE
                          XC(L) = XG8(IC(L),JC(L))
                          YC(L) = YG8(IC(L),JC(L))
                        END IF
                    ELSE
                      IF (TYPE_R4) THEN
                          XC(L) = XG4(JC(L),IC(L))
                          YC(L) = YG4(JC(L),IC(L))
                        ELSE
                          XC(L) = XG8(JC(L),IC(L))
                          YC(L) = YG8(JC(L),IC(L))
                        END IF
                    END IF
                END DO !L
!-------------check if cell includes a pole or branch cut
              LPL = .FALSE.
              LBC = .FALSE.
              IF ( LLG ) THEN
!-----------------shift longitudes to appropriate range
                  XC = MOD(XC,D360)
                  IF ( PTR%LCLO .OR. PTR%L360 ) THEN
                      WHERE ( XC.LT.ZERO ) XC = XC + D360
                    ELSE
                      WHERE ( XC.GT.D180 ) XC = XC - D360
                    END IF
!-----------------count longitudinal branch cut crossings
                  N = 0
                  DO L=1,4
                      K = MOD(L,4)+1
                      IF ( ABS(XC(K)-XC(L)) .GT. D180 ) N = N + 1
                    END DO
!-----------------multiple longitudinal branch cut crossing => cell includes branch cut
                  LBC = N.GT.1
!-----------------single longitudinal branch cut crossing
!                 or single vertex at 90 degrees => cell includes pole
                  LPL = N.EQ.1 .OR. COUNT(ABS(YC).EQ.D90).EQ.1
                END IF !LLG
!-------------set bucket id for each cell vertex
              DO L=1,4
                  IBC(L) = INT((XC(L)-PTR%XMIN)/PTR%DXB)+1
                  IF ( .NOT.PTR%LCLO ) IBC(L) = MIN(IBC(L),PTR%NBX)
                  JBC(L) = MIN(INT((YC(L)-PTR%YMIN)/PTR%DYB)+1,PTR%NBY)
                END DO !L
!-------------set bucket overlap bounds
              IF ( LPL ) THEN
!---------------cell includes pole: overlap includes full longitudinal range
                  NS = 1
                  IB1(1) = 1
                  IB2(1) = PTR%NBX
                  IF ( MINVAL(YC).GT.ZERO ) THEN
                      JB1(1) = MAX(1,MINVAL(JBC))
                      JB2(1) = PTR%NBY
                    END IF
                  IF ( MAXVAL(YC).LT.ZERO ) THEN
                      JB1(1) = 1
                      JB2(1) = MIN(PTR%NBY,MAXVAL(JBC))
                    END IF
                  IB1(2) = 0
                  IB2(2) = 0
                  JB1(2) = 0
                  JB2(2) = 0
                ELSE IF ( LBC ) THEN
!---------------cell includes branch cut: split overlap into two sets
                  NS = 2
                  IB1(1) = PTR%NBX
                  IB2(1) = PTR%NBX
                  IB1(2) = 1
                  IB2(2) = 1
                  DO L=1,4
                      IF ( IBC(L) .GT. PTR%NBX/2 ) THEN
                          IB1(1) = MIN(IB1(1),IBC(L))
                        ELSE
                          IB2(2) = MAX(IB2(2),IBC(L))
                        END IF
                    END DO !L
                  JB1(:) = MAX(1,MINVAL(JBC))
                  JB2(:) = MIN(PTR%NBY,MAXVAL(JBC))
                ELSE
!---------------default: overlap computed from min/max
                  NS = 1
                  IB1(1) = MAX(1,MINVAL(IBC))
                  IB2(1) = MIN(PTR%NBX,MAXVAL(IBC))
                  JB1(1) = MAX(1,MINVAL(JBC))
                  JB2(1) = MIN(PTR%NBY,MAXVAL(JBC))
                  IB1(2) = 0
                  IB2(2) = 0
                  JB1(2) = 0
                  JB2(2) = 0
                END IF
!-------------debug output
              IF ( LDBG .AND. ISTEP.EQ.1 ) THEN
                  WRITE(*,'(/A,2I6)')    'W3GSUC -- BUCKET SORT:',I,J
                  WRITE(*,'(A,2L6,1I6)') 'W3GSUC -- LBC,LPL:',LBC,LPL
                  WRITE(*,'(A,4I6)')     'W3GSUC -- IC:',IC(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- JC:',JC(:)
                  WRITE(*,'(A,4E24.16)') 'W3GSUC -- XC:',XC(:)
                  WRITE(*,'(A,4E24.16)') 'W3GSUC -- YC:',YC(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- IBC:',IBC(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- JBC:',JBC(:)
                  WRITE(*,'(A,1I6)')     'W3GSUC -- NS:',NS
                  WRITE(*,'(A,4I6)')     'W3GSUC -- IB1:',IB1(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- JB1:',JB1(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- IB2:',IB2(:)
                  WRITE(*,'(A,4I6)')     'W3GSUC -- JB2:',JB2(:)
                END IF
!-------------assign cell to buckets based on overlap
              DO K=1,NS
                  DO IB=IB1(K),IB2(K)
                      DO JB=JB1(K),JB2(K)
                          PTR%B(JB,IB)%N = PTR%B(JB,IB)%N + 1
                          IF ( ISTEP .EQ. 2 ) THEN
                              PTR%B(JB,IB)%I(PTR%B(JB,IB)%N) = IC(1)
                              PTR%B(JB,IB)%J(PTR%B(JB,IB)%N) = JC(1)
                            END IF
                        END DO !JB
                    END DO !IB
                END DO !K
            END DO !J
        END DO !I
!
!-----END ISTEP_LOOP
      END DO ISTEP_LOOP
!
!-----create nearest-neighbor bucket search object
      PTR%NNB => W3NNSC(NINT(HALF*MAX(PTR%NBX,PTR%NBY)))
!
!-----print debug info
      IF ( LDBG ) THEN
          WRITE(*,'(/A,3I6,4E24.16)') 'W3GSUC - search bucket list:'
          WRITE(*,'(3A6,4A14)') 'I','J','N','X1','Y1','X2','Y2'
          DO IB=1,PTR%NBX
              DO JB=1,PTR%NBY
                  WRITE(*,'(3I6,4E24.16)') IB,JB,PTR%B(JB,IB)%N, &
                    PTR%XMIN+(IB-1)*PTR%DXB,PTR%YMIN+(JB-1)*PTR%DYB, &
                    PTR%XMIN+(IB-0)*PTR%DXB,PTR%YMIN+(JB-0)*PTR%DYB
                END DO
            END DO
        END IF
!
! -------------------------------------------------------------------- /
! 5.  Set return parameter
!
      GSU%PTR => PTR

      END FUNCTION GSU_CREATE
!/
!/ End of W3GSUC ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3GSUD( GSU )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Destroy grid search utility (GSU) object.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous creation of grid-search-utility object.
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3GSUD( GSU )
      TYPE(T_GSU), INTENT(INOUT) :: GSU

!     Local parameters
      INTEGER :: IB, JB
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GSUD')
!
      IF ( ASSOCIATED(GSU%PTR) ) THEN
!
          CALL W3NNSD(GSU%PTR%NNP)
!
          DO IB=1,GSU%PTR%NBX
              DO JB=1,GSU%PTR%NBY
                  IF ( GSU%PTR%B(JB,IB)%N .GT. 0 ) THEN
                      DEALLOCATE(GSU%PTR%B(JB,IB)%I)
                      NULLIFY(GSU%PTR%B(JB,IB)%I)
                      DEALLOCATE(GSU%PTR%B(JB,IB)%J)
                      NULLIFY(GSU%PTR%B(JB,IB)%J)
                    END IF
                END DO
            END DO
          DEALLOCATE(GSU%PTR%B)
          NULLIFY(GSU%PTR%B)
!
          DEALLOCATE(GSU%PTR)
          NULLIFY(GSU%PTR)
!
        END IF

      END SUBROUTINE W3GSUD
!/
!/ End of W3GSUD ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3GSUP( GSU, IUNIT, LFULL )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Print grid-search-utility (GSU) object to IUNIT.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       IUNIT   Int.   I   OPTIONAL unit for output. Default is stdout.
!       LFULL   Log.   I   OPTIONAL logical flag to turn on full-output
!                          mode.  Default is FALSE.  When full-output
!                          is enabled the search bucket cell lists and
!                          nearest-neighbor point search indices are output.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous creation of grid-search-utility object.
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3GSUP( GSU, IUNIT, LFULL )
      TYPE(T_GSU), INTENT(IN) :: GSU
      INTEGER, OPTIONAL, INTENT(IN) :: IUNIT
      LOGICAL, OPTIONAL, INTENT(IN) :: LFULL

!     Local parameters
      INTEGER, PARAMETER :: NBYTE_PTR=4
      INTEGER, PARAMETER :: NBYTE_INT=4
      TYPE(CLASS_GSU), POINTER :: PTR
      INTEGER :: NDST, I, J, K, L, N, IB, JB, NBYTE
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GSUP')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GSUP ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF

      IF ( PRESENT(IUNIT) ) THEN
          NDST = IUNIT
        ELSE
          NDST = 6
        END IF

      PTR => GSU%PTR
!
! -------------------------------------------------------------------- /
! 2.  Compute approximate memory usage
!
      NBYTE = (NBYTE_INT+NBYTE_PTR*2)*SIZE(PTR%B)
      DO IB=1,PTR%NBX
      DO JB=1,PTR%NBY
          NBYTE = NBYTE + NBYTE_INT*2*PTR%B(JB,IB)%N
        END DO
        END DO
!
! -------------------------------------------------------------------- /
! 3.  Output
!
      WRITE(NDST,'(//80A)') ('-',K=1,80)
      WRITE(NDST,'(A)') 'Report on grid search utility object'
      WRITE(NDST,'( 80A)') ('-',K=1,80)
      WRITE(NDST,'(A,1L2)') 'Grid  ijg:',PTR%IJG
      WRITE(NDST,'(A,1L2)') 'Grid  llg:',PTR%LLG
      WRITE(NDST,'(A,1I2)') 'Grid iclo:',PTR%ICLO
      WRITE(NDST,'(A,1L2)') 'Grid lclo:',PTR%LCLO
      WRITE(NDST,'(A,1I2)') 'Grid precision:',PTR%GKIND
      WRITE(NDST,'(A,2I6)') 'Grid lbx,lby:',PTR%LBX,PTR%LBY
      WRITE(NDST,'(A,2I6)') 'Grid ubx,uby:',PTR%UBX,PTR%UBY
      WRITE(NDST,'(A,2I6)') 'Grid nx,ny:',PTR%NX,PTR%NY
      IF ( PRESENT(LFULL) ) THEN
          IF ( LFULL ) THEN
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(A)') 'Nearest-neighbor point search indices'
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              CALL W3NNSP(PTR%NNP,NDST)
            END IF
        END IF
      WRITE(NDST,'( 80A)') ('-',K=1,80)
      WRITE(NDST,'(A)') 'Bucket-search object'
      WRITE(NDST,'( 80A)') ('-',K=1,80)
      WRITE(NDST,'(A,4E24.16)') 'Spatial grid search domain: ', &
      PTR%XMIN,PTR%YMIN,PTR%XMAX,PTR%YMAX
      WRITE(NDST,'(A,2I6)') 'nbx,nby:',PTR%NBX,PTR%NBY
      WRITE(NDST,'(A,2E24.16)') 'dxb,dyb:',PTR%DXB,PTR%DYB
      WRITE(NDST,'(A,1F10.1)') 'Approximate memory usage (MB):', &
      REAL(NBYTE)/2**20
      IF ( PRESENT(LFULL) ) THEN
          IF ( LFULL ) THEN
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(A)') 'Search bucket bounds:'
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(2A4,4A24)') 'IB','JB','X1','Y1','X2','Y2'
              DO IB=1,PTR%NBX
              DO JB=1,PTR%NBY
                  WRITE(*,'(2I4,4E24.16)') IB,JB, &
                  PTR%XMIN+(IB-1)*PTR%DXB,PTR%YMIN+(JB-1)*PTR%DYB, &
                  PTR%XMIN+(IB  )*PTR%DXB,PTR%YMIN+(JB  )*PTR%DYB
                END DO
                END DO
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(A)') 'Number of cells in each search bucket:'
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              DO JB=PTR%NBY,1,-1
                  WRITE(NDST,'(500I4)') (PTR%B(JB,IB)%N,IB=1,PTR%NBX)
                END DO
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(A)') 'Search bucket cell lists:'
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(3A4,A)') 'IB','JB','NC',': ( IC, JC), ...'
              DO JB=1,PTR%NBY
              DO IB=1,PTR%NBX
                  WRITE(NDST,'(3I4,A,500(A,I3,A,I3,A))') IB,JB, &
                  PTR%B(JB,IB)%N, ': ', &
                  ( '(',PTR%B(JB,IB)%I(K),',',PTR%B(JB,IB)%J(K),') ', &
                    K=1,PTR%B(JB,IB)%N )
                END DO
                END DO
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              WRITE(NDST,'(A)') 'Nearest-neighbor bucket search indices'
              WRITE(NDST,'( 80A)') ('-',K=1,80)
              CALL W3NNSP(PTR%NNB,NDST)
            END IF !LFULL
        END IF !PRESENT(LFULL)
      WRITE(NDST,'( 80A)') ('-',K=1,80)
      WRITE(NDST,'( 80A)') ('-',K=1,80)

      END SUBROUTINE W3GSUP
!/
!/ End of W3GSUP ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GFCL( GSU, XT, YT, IS, JS, XS, YS, &
!/                     POLE, EPS, FNCL, DEBUG ) RESULT(INGRID)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Find cell in grid, associated with the input grid-search-utility
!     object (GSU), that encloses the target point (xt,yt).
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INGRID  Log.   O   Logical flag indicating if target point lies
!                          within the source grid domain.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       XT      Real   I   X-coordinate of target point.
!       YT      Real   I   Y-coordinate of target point.
!       IS,JS   I.A.   O   (I,J) indices of vertices of enclosing grid cell.
!       XS,YS   R.A.   O   (X,Y) coord. of vertices of enclosing grid cell.
!       POLE    Log.   O   OPTIONAL logical flag to indicate whether or not
!                          the enclosing grid cell includes a pole.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check if
!                          target point is in domain and for point coincidence.
!       FNCL    Log.   I   OPTIONAL logical flag to enable finding cell that
!                          is shortest distance from target point when the
!                          target point is not located in the source grid.
!                          Default is FALSE.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous creation of grid-search-utility object.
!
!  7. Remarks :
!
!     - The target point coordinates may be modified by this routine.
!     - The target point longitude will be shifted to the source grid
!       longitudinal range.
!     - If enclosing cell includes a branch cut, then the coordinates of
!       of the cell vertices AND the target point will be adjusted so
!       that the branch cut is shifted 180 degrees.
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Initialize search
!      3.  Search for enclosing cell in central and nearest nbr buckets
!      4.  If not in grid and find nearest cell is enabled, then
!          identify cell closest to target point
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFCL_R4( GSU, XT, YT, IS, JS, XS, YS, &
                          POLE, EPS, FNCL, DEBUG ) RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(4), INTENT(INOUT)  :: XT
      REAL(4), INTENT(INOUT)  :: YT
      INTEGER, INTENT(INOUT)  :: IS(4), JS(4)
      REAL(4), INTENT(INOUT)  :: XS(4), YS(4)
      LOGICAL, INTENT(OUT),OPTIONAL :: POLE
      REAL(4), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: FNCL
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, XS8(4), YS8(4), EPS8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFCL_R4')
!
!-----set inputs
      XT8 = XT; YT8 = YT;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
!
!-----call double precision method
      INGRID = W3GFCL( GSU, XT8, YT8, IS, JS, XS8, YS8, POLE=POLE, &
                       EPS=EPS8, FNCL=FNCL, DEBUG=DEBUG )
!
!-----set outputs
      XT = XT8; YT = YT8;
      XS = XS8; YS = YS8;

      END FUNCTION W3GFCL_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFCL_R8( GSU, XT, YT, IS, JS, XS, YS, &
                          POLE, EPS, FNCL, DEBUG ) RESULT(INGRID)
!     Double precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(8), INTENT(INOUT)  :: XT
      REAL(8), INTENT(INOUT)  :: YT
      INTEGER, INTENT(INOUT)  :: IS(4), JS(4)
      REAL(8), INTENT(INOUT)  :: XS(4), YS(4)
      LOGICAL, INTENT(OUT),OPTIONAL :: POLE
      REAL(8), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: FNCL
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: LEPS
      LOGICAL :: LDBG, LPLC, LFNCL, INCELL
      INTEGER :: I, J, K, L, N, IB, JB
      LOGICAL :: IJG, LLG, LCLO, L360
      INTEGER :: ICLO, GKIND
      INTEGER :: LBX, LBY, UBX, UBY, NX, NY
      REAL(4), POINTER :: XG4(:,:), YG4(:,:)
      REAL(8), POINTER :: XG8(:,:), YG8(:,:)
      INTEGER :: NBX, NBY
      REAL(8) :: DXB, DYB, XMIN, XMAX, YMIN, YMAX
      TYPE(T_BKT), POINTER :: B(:,:)
      TYPE(T_NNS), POINTER :: NNB
      LOGICAL :: FOUND
      INTEGER :: NLEVEL, LVL, LVL1, N1, IB0, JB0, IB1, JB1, K1
      INTEGER :: IS1(4), JS1(4)
      REAL(8) :: XS1(4), YS1(4), XSM, YSM, DD, DD1
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFCL_R8')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/2A/)') 'W3GFCL_R8 ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF
      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GFCL_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Initialize search
!
      IF ( PRESENT(FNCL) ) THEN
          LFNCL = FNCL
        ELSE
          LFNCL = .FALSE.
        END IF
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!  Local pointers to grid search utility object data
      IJG = GSU%PTR%IJG
      LLG = GSU%PTR%LLG
      ICLO = GSU%PTR%ICLO
      LCLO = GSU%PTR%LCLO
      L360 = GSU%PTR%L360
      GKIND = GSU%PTR%GKIND
      LBX = GSU%PTR%LBX;  LBY = GSU%PTR%LBY;
      UBX = GSU%PTR%UBX;  UBY = GSU%PTR%UBY;
      NX = GSU%PTR%NX;  NY = GSU%PTR%NY;
      IF ( GKIND.EQ.4 ) THEN
          XG4 => GSU%PTR%XG4;  YG4 => GSU%PTR%YG4;
        ELSE
          XG8 => GSU%PTR%XG8;  YG8 => GSU%PTR%YG8;
        END IF
      NBX = GSU%PTR%NBX;  NBY = GSU%PTR%NBY;
      DXB = GSU%PTR%DXB;  DYB = GSU%PTR%DYB;
      XMIN = GSU%PTR%XMIN;  YMIN = GSU%PTR%YMIN;
      XMAX = GSU%PTR%XMAX;  YMAX = GSU%PTR%YMAX;
      B => GSU%PTR%B
      NNB => GSU%PTR%NNB
!
      INGRID = .FALSE.
!
!  Shift target to appropriate longitude range
      IF ( LLG ) THEN
          XT = MOD(XT,REAL(D360,8))
          IF ( LCLO .OR. L360 ) THEN
              IF ( XT.LT.ZERO ) XT = XT + D360
            ELSE
              IF ( XT.GT.D180 ) XT = XT - D360
            END IF
        END IF
      IF ( LDBG ) WRITE(*,'(/A,2E24.16)') 'W3GFCL_R8 - TARGET POINT:',XT,YT
!
!  Target point must lie within search domain
      IF ( .NOT.LFNCL ) THEN
        IF ( XT.LT.XMIN-LEPS .OR. XT.GT.XMAX+LEPS .OR. &
             YT.LT.YMIN-LEPS .OR. YT.GT.YMAX+LEPS ) THEN
            IF ( LDBG ) WRITE(*,'(A)') &
            'W3GFCL_R8 - TARGET POINT OUTSIDE SEARCH DOMAIN'
            RETURN
          END IF
        END IF
!
!  Search bucket that contains the target point.
      IB = MAX(INT((XT-XMIN)/DXB)+1,1);  IF ( .NOT.LCLO ) IB = MIN(IB,NBX);
      JB = MAX(INT((YT-YMIN)/DYB)+1,1);                   JB = MIN(JB,NBY);
!
! -------------------------------------------------------------------- /
! 3.  Search for enclosing cell in bucket
!
      IF ( LDBG ) &
      WRITE(*,'(A,3I6,4E24.16)') &
      'W3GFCL_R8 - BUCKET SEARCH:',IB,JB,B(JB,IB)%N, &
      XMIN+(IB-1)*DXB,YMIN+(JB-1)*DYB,XMIN+IB*DXB,YMIN+JB*DYB
      CELL_LOOP: DO K=1,B(JB,IB)%N
!---------setup cell corner indices
          IS(1) = B(JB,IB)%I(K)  ;  JS(1) = B(JB,IB)%J(K)  ;
          IS(2) = B(JB,IB)%I(K)+1;  JS(2) = B(JB,IB)%J(K)  ;
          IS(3) = B(JB,IB)%I(K)+1;  JS(3) = B(JB,IB)%J(K)+1;
          IS(4) = B(JB,IB)%I(K)  ;  JS(4) = B(JB,IB)%J(K)+1;
!---------setup cell corner coordinates and adjust for periodicity
          DO L=1,4
!-------------i-closure
              IF ( MOD(ICLO,2).EQ.0 ) THEN
                  IF ( IS(L) .LT. LBX ) IS(L) = IS(L) + NX
                  IF ( IS(L) .GT. UBX ) IS(L) = IS(L) - NX
                END IF
!-------------j-closure
              IF ( MOD(ICLO,3).EQ.0 ) THEN
                  IF ( JS(L) .LT. LBY ) JS(L) = JS(L) + NY
                  IF ( JS(L) .GT. UBY ) JS(L) = JS(L) - NY
                END IF
              IF ( ICLO.EQ.ICLO_TRPL ) THEN
                  IF ( JS(L) .GT. UBY ) THEN
                      JS(L) = UBY
                      IS(L) = NX - MOD(IS(L)-1,NX)
                    END IF
                END IF
!-------------copy cell vertex coordinates into local variables
              IF ( IJG ) THEN
                  IF ( GKIND.EQ.4 ) THEN
                      XS(L) = XG4(IS(L),JS(L));  YS(L) = YG4(IS(L),JS(L));
                    ELSE
                      XS(L) = XG8(IS(L),JS(L));  YS(L) = YG8(IS(L),JS(L));
                    END IF
                ELSE
                  IF ( GKIND.EQ.4 ) THEN
                      XS(L) = XG4(JS(L),IS(L));  YS(L) = YG4(JS(L),IS(L));
                    ELSE
                      XS(L) = XG8(JS(L),IS(L));  YS(L) = YG8(JS(L),IS(L));
                    END IF
                END IF
!-------------shift longitudes to same range
              IF ( LLG ) THEN
                  XS(L) = MOD(XS(L),REAL(D360,8))
                  IF ( LCLO .OR. L360 ) THEN
                      IF ( XS(L).LT.ZERO ) XS(L) = XS(L) + D360
                    ELSE
                      IF ( XS(L).GT.D180 ) XS(L) = XS(L) - D360
                    END IF
                END IF
            END DO !L
          IF ( LDBG ) &
          WRITE(*,'(A,3I6,4(/A,1I1,A,2I6,2E24.16))') &
          'W3GFCL_R8 - CHECK CELL:',IB,JB,K, &
          ('          CORNER(',L,'):',IS(L),JS(L),XS(L),YS(L),L=1,4)
!---------check if point is enclosed in cell defined by xs(1:4) & ys(1:4)
          INCELL = W3CKCL(LLG,XT,YT,4,XS,YS,LPLC,LEPS,LDBG)
          IF ( LDBG ) WRITE(*,'(A,1L2)')'W3GFCL_R8 - INCELL:',INCELL
          IF ( INCELL ) THEN
!-------------exit search
              IF ( LDBG ) &
              WRITE(*,'(A,3I6,4(2I6))') &
              'W3GFCL_R8 - ENCLOSING CELL:',IB,JB,K,(IS(L),JS(L),L=1,4)
              IF ( PRESENT(POLE) ) POLE = LPLC
              INGRID = .TRUE.
              EXIT CELL_LOOP 
            END IF !point in cell
        END DO CELL_LOOP
      IF ( INGRID ) RETURN
      IF ( .NOT.LFNCL ) RETURN
!
! -------------------------------------------------------------------- /
! 4.  If not in grid, then identify cell closest to target point
!
!-----find closest cell by search nearest-neighbor buckets
      NLEVEL = 0
      DD1 = HUGE(XT)
      IB0 = IB;  JB0 = JB;
      IB1 = IB;  JB1 = JB;
      NNB = W3NNSC(NINT(HALF*MAX(NBX,NBY)))
      IF ( LDBG ) WRITE(*,'(A,3I6)') &
      'W3GFCL_R8 - CLOSEST CELL SEARCH:',IB0,JB0,NNB%NLVL
      LEVEL_LOOP: DO LVL=1,NNB%NLVL
          FOUND = .FALSE.
          NNBR_LOOP: DO N=NNB%N1(LVL),NNB%N2(LVL)
              IB = IB0 + NNB%DI(N);  JB = JB0 + NNB%DJ(N);
              IF ( IB.LT.1 .OR. IB.GT.NBX ) CYCLE NNBR_LOOP
              IF ( JB.LT.1 .OR. JB.GT.NBY ) CYCLE NNBR_LOOP
              IF ( LDBG ) WRITE(*,'(A,5I6)') &
              'W3GFCL_R8 - CHECK BUCKET:',LVL,N,IB,JB,B(JB,IB)%N
              CELL_LOOP2: DO K=1,B(JB,IB)%N
!-----------------setup cell corner indices
                  IS(1) = B(JB,IB)%I(K)  ;  JS(1) = B(JB,IB)%J(K)  ;
                  IS(2) = B(JB,IB)%I(K)+1;  JS(2) = B(JB,IB)%J(K)  ;
                  IS(3) = B(JB,IB)%I(K)+1;  JS(3) = B(JB,IB)%J(K)+1;
                  IS(4) = B(JB,IB)%I(K)  ;  JS(4) = B(JB,IB)%J(K)+1;
!-----------------setup cell corner coordinates and adjust for periodicity
                  DO L=1,4
!---------------------i-closure
                      IF ( MOD(ICLO,2).EQ.0 ) THEN
                          IF ( IS(L) .LT. LBX ) IS(L) = IS(L) + NX
                          IF ( IS(L) .GT. UBX ) IS(L) = IS(L) - NX
                        END IF
!---------------------j-closure
                      IF ( MOD(ICLO,3).EQ.0 ) THEN
                          IF ( JS(L) .LT. LBY ) JS(L) = JS(L) + NY
                          IF ( JS(L) .GT. UBY ) JS(L) = JS(L) - NY
                        END IF
                      IF ( ICLO.EQ.ICLO_TRPL ) THEN
                          IF ( JS(L) .GT. UBY ) THEN
                              JS(L) = UBY
                              IS(L) = NX - MOD(IS(L)-1,NX)
                            END IF
                        END IF
!---------------------copy cell vertex coordinates into local variables
                      IF ( IJG ) THEN
                          IF ( GKIND.EQ.4 ) THEN
                              XS(L) = XG4(IS(L),JS(L));  YS(L) = YG4(IS(L),JS(L));
                            ELSE
                              XS(L) = XG8(IS(L),JS(L));  YS(L) = YG8(IS(L),JS(L));
                            END IF
                        ELSE
                          IF ( GKIND.EQ.4 ) THEN
                              XS(L) = XG4(JS(L),IS(L));  YS(L) = YG4(JS(L),IS(L));
                            ELSE
                              XS(L) = XG8(JS(L),IS(L));  YS(L) = YG8(JS(L),IS(L));
                            END IF
                        END IF
!---------------------shift longitudes to same range
                      IF ( LLG ) THEN
                          XS(L) = MOD(XS(L),REAL(D360,8))
                          IF ( LCLO .OR. L360 ) THEN
                              IF ( XS(L).LT.ZERO ) XS(L) = XS(L) + D360
                            ELSE
                              IF ( XS(L).GT.D180 ) XS(L) = XS(L) - D360
                            END IF
                        END IF
                    END DO !L
!-----------------check cell distance from target point
                  XSM = SUM(XS)/FOUR; YSM = SUM(YS)/FOUR;
                  DD = W3DIST(LLG,XT,YT,XSM,YSM)
                  IF ( LDBG ) &
                  WRITE(*,'(A,5I6,3E24.16,4(/A,1I1,A,2I6,2E24.16))') &
                  'W3GFCL_R8 - CHECK CELL:',LVL,N,IB,JB,K,XSM,YSM,DD, &
                  ('          CORNER(',L,'):',IS(L),JS(L),XS(L),YS(L),L=1,4)
                  IF (DD.LT.DD1) THEN
                      LVL1   = LVL
                      N1     = N
                      IB1    = IB
                      JB1    = JB
                      K1     = K
                      DD1    = DD
                      IS1(:) = IS(:)
                      JS1(:) = JS(:)
                      XS1(:) = XS(:)
                      YS1(:) = YS(:)
                    ENDIF
                  FOUND = .TRUE.
                END DO CELL_LOOP2
            END DO NNBR_LOOP
            IF ( FOUND ) NLEVEL = NLEVEL + 1
            IF ( NLEVEL .GE. MAX_FNCL_LEVEL ) EXIT LEVEL_LOOP
        END DO LEVEL_LOOP
!
!-----return cell that is shortest distance from target point 
      IS(:) = IS1(:)
      JS(:) = JS1(:)
      XS(:) = XS1(:)
      YS(:) = YS1(:)
      IF ( LDBG ) &
      WRITE(*,'(A,5I6,1E24.16,4(/A,1I1,A,2I6,2E24.16))') &
      'W3GFCL_R8 - CLOSEST CELL:',LVL1,N1,IB1,JB1,K1,DD1, &
      ('          CORNER(',L,'):',IS(L),JS(L),XS(L),YS(L),L=1,4)
!
!-----check if cell includes a pole or branch cut
      IF ( LLG ) THEN
          N = 0
!---------count longitudinal branch cut crossings
          DO I=1,4
              J = MOD(I,4) + 1
              IF ( ABS(XS(J)-XS(I)) .GT. D180 ) N = N + 1
            END DO
!---------single longitudinal branch cut crossing
!         or single vertex at 90 degrees => cell includes pole
          LPLC = N.EQ.1 .OR. COUNT(ABS(YS).EQ.D90).EQ.1
          IF ( LPLC .AND. LDBG ) &
          WRITE(*,'(A)') 'W3GFCL_R8 - CELL INCLUDES A POLE'
        ELSE
          LPLC = .FALSE.
        END IF
      IF ( PRESENT(POLE) ) POLE = LPLC

      END FUNCTION W3GFCL_R8
!/
!/ End of W3GFCL ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GFCD_R4( GSU, XT, YT, IS, JS, XS, YS, POLE, EPS, DEBUG ) &
!/    RESULT(INGRID)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Find cell in grid, associated with the input grid-search-utility
!     object (GSU), that encloses the target point (xt,yt), using direct
!     grid search (i.e., no bucket search).
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INGRID  Log.   O   Logical flag indicating if target point lies
!                          within the source grid domain.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       XT      Real   I   X-coordinate of target point.
!       YT      Real   I   Y-coordinate of target point.
!       IS,JS   I.A.   O   (I,J) indices of vertices of enclosing grid cell.
!       XS,YS   R.A.   O   (X,Y) coord. of vertices of enclosing grid cell.
!       POLE    Log.   O   OPTIONAL logical flag to indicate whether or not
!                          the enclosing grid cell includes a pole.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check if
!                          target point is in domain and for point coincidence.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous creation of grid-search-utility object.
!
!  7. Remarks :
!
!     - The target point coordinates may be modified by this routine.
!     - The target point longitude will be shifted to the source grid
!       longitudinal range.
!     - If enclosing cell includes a branch cut, then the coordinates of
!       of the cell vertices AND the target point will be adjusted so
!       that the branch cut is shifted 180 degrees.
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Initialize search
!      3.  Search for enclosing cell
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFCD_R4( GSU, XT, YT, IS, JS, XS, YS, &
                          POLE, EPS, DEBUG ) RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(4), INTENT(INOUT)  :: XT
      REAL(4), INTENT(INOUT)  :: YT
      INTEGER, INTENT(INOUT)  :: IS(4), JS(4)
      REAL(4), INTENT(INOUT)  :: XS(4), YS(4)
      LOGICAL, INTENT(OUT),OPTIONAL :: POLE
      REAL(4), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, XS8(4), YS8(4), EPS8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFCD_R4')
!
!-----set inputs
      XT8 = XT; YT8 = YT;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
!
!-----call double precision method
      INGRID = W3GFCD( GSU, XT8, YT8, IS, JS, XS8, YS8, POLE=POLE, &
                       EPS=EPS8, DEBUG=DEBUG )
!
!-----set outputs
      XT = XT8; YT = YT8;
      XS = XS8; YS = YS8;

      END FUNCTION W3GFCD_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFCD_R8( GSU, XT, YT, IS, JS, XS, YS, &
                          POLE, EPS, DEBUG ) RESULT(INGRID)
!     Double precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(8), INTENT(INOUT)  :: XT
      REAL(8), INTENT(INOUT)  :: YT
      INTEGER, INTENT(INOUT)  :: IS(4), JS(4)
      REAL(8), INTENT(INOUT)  :: XS(4), YS(4)
      LOGICAL, INTENT(OUT),OPTIONAL :: POLE
      REAL(8), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: LEPS
      LOGICAL :: LDBG, LPLC
      INTEGER :: I, J, K, L, N, IB, JB
      LOGICAL :: IJG, LLG, LCLO, L360
      INTEGER :: ICLO, GKIND
      INTEGER :: LBX, LBY, UBX, UBY, NX, NY
      INTEGER :: LXC, LYC, UXC, UYC
      REAL(4), POINTER :: XG4(:,:), YG4(:,:)
      REAL(8), POINTER :: XG8(:,:), YG8(:,:)
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFCD_R8')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/2A/)') 'W3GFCD_R8 ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF
      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GFCD_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Initialize search
!
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!  Local pointers to grid search utility object data
      IJG = GSU%PTR%IJG
      LLG = GSU%PTR%LLG
      ICLO = GSU%PTR%ICLO
      LCLO = GSU%PTR%LCLO
      L360 = GSU%PTR%L360
      GKIND = GSU%PTR%GKIND
      LBX = GSU%PTR%LBX;  LBY = GSU%PTR%LBY;
      UBX = GSU%PTR%UBX;  UBY = GSU%PTR%UBY;
      NX = GSU%PTR%NX;  NY = GSU%PTR%NY;
      IF ( GKIND.EQ.4 ) THEN
          XG4 => GSU%PTR%XG4;  YG4 => GSU%PTR%YG4;
        ELSE
          XG8 => GSU%PTR%XG8;  YG8 => GSU%PTR%YG8;
        END IF
!
      INGRID = .FALSE.
!
!  Shift target to appropriate longitude range
      IF ( LLG ) THEN
          XT = MOD(XT,REAL(D360,8))
          IF ( LCLO .OR. L360 ) THEN
              IF ( XT.LT.ZERO ) XT = XT + D360
            ELSE
              IF ( XT.GT.D180 ) XT = XT - D360
            END IF
        END IF
      IF ( LDBG ) &
      WRITE(*,'(/A,2E24.16)') 'W3GFCD_R8 - TARGET POINT:',XT,YT

!-----number of cells
      LXC = LBX;  LYC = LBY;
      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE )
            UXC = UBX-1;  UYC = UBY-1;
          CASE ( ICLO_GRDI )
            UXC = UBX;    UYC = UBY-1;
          CASE ( ICLO_GRDJ )
            UXC = UBX-1;  UYC = UBY;
          CASE ( ICLO_TRDL )
            UXC = UBX;    UYC = UBY;
          CASE ( ICLO_TRPL )
            UXC = UBX;    UYC = UBY;
        END SELECT
!
! -------------------------------------------------------------------- /
! 3.  Search for enclosing cell
!
      CELL_LOOP: DO I=LXC,UXC
          DO J=LYC,UYC
!-------------create list of cell vertices
              IS(1) = I  ;  JS(1) = J  ;
              IS(2) = I+1;  JS(2) = J  ;
              IS(3) = I+1;  JS(3) = J+1;
              IS(4) = I  ;  JS(4) = J+1;
!-------------setup cell corner coordinates and adjust for periodicity
              DO L=1,4
!-----------------i-closure
                  IF ( MOD(ICLO,2).EQ.0 ) THEN
                      IF ( IS(L) .LT. LBX ) IS(L) = IS(L) + NX
                      IF ( IS(L) .GT. UBX ) IS(L) = IS(L) - NX
                    END IF
!-----------------j-closure
                  IF ( MOD(ICLO,3).EQ.0 ) THEN
                      IF ( JS(L) .LT. LBY ) JS(L) = JS(L) + NY
                      IF ( JS(L) .GT. UBY ) JS(L) = JS(L) - NY
                    END IF
                  IF ( ICLO.EQ.ICLO_TRPL ) THEN
                      IF ( JS(L) .GT. UBY ) THEN
                          JS(L) = UBY
                          IS(L) = NX - MOD(IS(L)-1,NX)
                        END IF
                    END IF
!-----------------copy cell vertex coordinates into local variables
                  IF ( IJG ) THEN
                      IF ( GKIND.EQ.4 ) THEN
                          XS(L) = XG4(IS(L),JS(L));  YS(L) = YG4(IS(L),JS(L));
                        ELSE
                          XS(L) = XG8(IS(L),JS(L));  YS(L) = YG8(IS(L),JS(L));
                        END IF
                    ELSE
                      IF ( GKIND.EQ.4 ) THEN
                          XS(L) = XG4(JS(L),IS(L));  YS(L) = YG4(JS(L),IS(L));
                        ELSE
                          XS(L) = XG8(JS(L),IS(L));  YS(L) = YG8(JS(L),IS(L));
                        END IF
                    END IF
!-----------------shift longitudes to same range
                  IF ( LLG ) THEN
                      XS(L) = MOD(XS(L),REAL(D360,8))
                      IF ( LCLO .OR. L360 ) THEN
                          IF ( XS(L).LT.ZERO ) XS(L) = XS(L) + D360
                        ELSE
                          IF ( XS(L).GT.D180 ) XS(L) = XS(L) - D360
                        END IF
                    END IF
                END DO !L
              IF ( LDBG ) &
              WRITE(*,'(A,4(/A,1I1,A,2I6,2E24.16))') &
              'W3GFCD_R8 - CHECK CELL:', &
              ('          CORNER(',L,'):',IS(L),JS(L),XS(L),YS(L),L=1,4)
!-------------check if point is enclosed in cell defined by xs(1:4) & ys(1:4)
              INGRID = W3CKCL(LLG,XT,YT,4,XS,YS,LPLC,LEPS,LDBG)
              IF ( LDBG ) WRITE(*,'(A,1L2)')'W3GFCD_R8 - INGRID:',INGRID
              IF ( INGRID ) THEN
!-----------------exit search
                  IF ( LDBG ) &
                  WRITE(*,'(A,4(2I6))') &
                  'W3GFCD_R8 - ENCLOSING CELL:',(IS(L),JS(L),L=1,4)
                  IF ( PRESENT(POLE) ) POLE = LPLC
                EXIT CELL_LOOP 
              END IF !point in cell
            END DO !J
        END DO CELL_LOOP

      END FUNCTION W3GFCD_R8
!/
!/ End of W3GFCD ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GFPT( GSU, XTIN, YTIN, IX, IY, DEBUG ) &
!/    RESULT(INGRID)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Find point in grid, associated with the input grid-search-utility
!     object (GSU), that is closest to the target point (xtin,ytin).
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INGRID  Log.   O   Logical flag indicating if target point lies
!                          within the source grid domain.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       XTIN    Real   I   X-coordinate of target point.
!       YTIN    Real   I   Y-coordinate of target point.
!       IX,JX   I.A.   O   (I,J) indices of nearest grid point.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous initialization of grid search utility object.
!
!  7. Remarks :
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Initialize search
!      3.  Find enclosing cell and compute closest point
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFPT_R4( GSU, XTIN, YTIN, IX, IY, DEBUG ) &
      RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(4), INTENT(IN)     :: XTIN
      REAL(4), INTENT(IN)     :: YTIN
      INTEGER, INTENT(OUT)    :: IX, IY
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFPT_R4')
!
!-----set inputs
      XT8 = XTIN; YT8 = YTIN;
!
!-----call double precision method
      INGRID = W3GFPT( GSU, XT8, YT8, IX, IY, DEBUG=DEBUG )

      END FUNCTION W3GFPT_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFPT_R8( GSU, XTIN, YTIN, IX, IY, DEBUG ) &
      RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(8), INTENT(IN)     :: XTIN
      REAL(8), INTENT(IN)     :: YTIN
      INTEGER, INTENT(OUT)    :: IX, IY
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8), PARAMETER :: BIG = 1D16
      LOGICAL :: LDBG
      INTEGER :: I, J, K, L
      REAL(8) :: XT, YT
      INTEGER :: IS(4), JS(4)
      REAL(8) :: XS(4), YS(4)
      REAL(8) :: DD, DMIN
      LOGICAL :: IJG, LLG
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFPT_R8')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/2A/)') 'W3GFPT_R8 ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Initialize search
!
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!  Local pointers to grid search utility object data
      IJG = GSU%PTR%IJG
      LLG = GSU%PTR%LLG
!
      INGRID = .FALSE.
!
      XT = XTIN;  YT = YTIN;
      IF ( LDBG ) &
      WRITE(*,'(/A,2E24.16)') 'W3GFPT_R8 - TARGET POINT:',XT,YT
!
! -------------------------------------------------------------------- /
! 3.  Find enclosing cell and compute closest point
!
      INGRID = W3GFCL( GSU, XT, YT, IS, JS, XS, YS, DEBUG=LDBG )
      IF ( INGRID ) THEN
          DMIN = BIG
          DO L=1,4
              DD = W3DIST( LLG, XT, YT, XS(L), YS(L) )
              IF ( DD .LT. DMIN ) THEN
                  DMIN = DD;  IX = IS(L);  IY = JS(L);
                END IF
            END DO !L
        ELSE
          IX = 0;  IY = 0;
        END IF

      END FUNCTION W3GFPT_R8
!/
!/ End of W3GFPT ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GFIJ( GSU, XTIN, YTIN, IX, JX, EPS, DCIN, DEBUG ) &
!/    RESULT(INGRID)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute coordinates ( ix, jx ) of target point ( xtin, ytin ) in
!     source grid index space from source grid associated with the input
!     grid search utility object (GSU).
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INGRID  Log.   O   Logical flag indicating if target point lies
!                          within the source grid domain.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       XTIN    Real   I   X-coordinate of target point.
!       YTIN    Real   I   Y-coordinate of target point.
!       IX      Real   O   X-coordinate of target point in source grid
!                          index space.
!       JX      Real   O   Y-coordinate of target point in source grid
!                          index space.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check if
!                          target point is in domain and for point coincidence.
!       DCIN    Real   I   OPTIONAL distance outside of source grid in
!                          units of cell width to treat target point as
!                          inside the source grid.
!                          Default is 0.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous initialization of grid search utility object.
!     - Check on appropriate input of optional arguments.
!
!  7. Remarks :
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Initialize search
!      3.  Find enclosing cell and compute index coordinates
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFIJ_R4( GSU, XTIN, YTIN, IX, JX, EPS, DCIN, DEBUG ) &
      RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(4), INTENT(IN)     :: XTIN
      REAL(4), INTENT(IN)     :: YTIN
      REAL(4), INTENT(OUT)    :: IX
      REAL(4), INTENT(OUT)    :: JX
      REAL(4), INTENT(IN), OPTIONAL :: EPS
      REAL(4), INTENT(IN), OPTIONAL :: DCIN
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, IX8, JX8, EPS8, DCIN8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFIJ_R4')
!
!-----set inputs
      XT8 = XTIN; YT8 = YTIN;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
      IF ( PRESENT(DCIN) ) THEN
          DCIN8 = DCIN
        ELSE
          DCIN8 = ZERO
        END IF
!
!-----call double precision method
      INGRID = W3GFIJ( GSU, XT8, YT8, IX8, JX8, EPS=EPS8, DCIN=DCIN8, &
                       DEBUG=DEBUG )
!
!-----set outputs
      IX = IX8; JX = JX8;

      END FUNCTION W3GFIJ_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GFIJ_R8( GSU, XTIN, YTIN, IX, JX, EPS, DCIN, DEBUG ) &
      RESULT(INGRID)
!     Double precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(8), INTENT(IN)     :: XTIN
      REAL(8), INTENT(IN)     :: YTIN
      REAL(8), INTENT(OUT)    :: IX
      REAL(8), INTENT(OUT)    :: JX
      REAL(8), INTENT(IN), OPTIONAL :: EPS
      REAL(8), INTENT(IN), OPTIONAL :: DCIN
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: LEPS
      INTEGER :: LDCIN, I
      LOGICAL :: LDBG, FNCL, POLE
      INTEGER :: IS(4), JS(4)
      REAL(8) :: XT, YT, XS(4), YS(4)
      REAL(8) :: XTC, YTC, XSC(4), YSC(4)
      REAL(8) :: IXR, JXR, DD, LON0, LAT0
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GFIJ_R8')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/2A/)') 'W3GFIJ_R8 ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF
      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GFIJ_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
      IF ( PRESENT(DCIN) ) THEN
          IF ( DCIN .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GFIJ_R8 ERROR -- ', &
              'DCIN parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LDCIN = DCIN
        ELSE
          LDCIN = ZERO
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Initialize search
!
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
      XT = XTIN;  YT = YTIN;
      IF ( LDBG ) WRITE(*,'(/A,2E24.16)') 'W3GFIJ_R8 - TARGET POINT:',XT,YT
!
! -------------------------------------------------------------------- /
! 3.  Find enclosing cell and compute point location
!
      FNCL = LDCIN .GT. ZERO
      INGRID = W3GFCL(GSU,XT,YT,IS,JS,XS,YS,POLE=POLE,EPS=LEPS,FNCL=FNCL,DEBUG=LDBG)
      IF ( .NOT.INGRID .AND. .NOT.FNCL ) RETURN
!
!-----Compute cell relative index space location
      LON0 = SUM(XS)/FOUR; LAT0 = SUM(YS)/FOUR;
      IF ( D90-ABS(LAT0).GT.NEAR_POLE ) THEN
!---------non-pole cell: compute relative location using (lon,lat)
          CALL W3RMBL(XT,YT,XS,YS,IX=IXR,JX=JXR,EPS=LEPS,DEBUG=LDBG)
        ELSE
!---------pole cell: compute relative location using stereographic projection
          CALL W3SPLX(LON0,LAT0,ZERO,XT,YT,XTC,YTC)
          DO I=1,4
              CALL W3SPLX(LON0,LAT0,ZERO,XS(I),YS(I),XSC(I),YSC(I))
            END DO
          CALL W3RMBL(XTC,YTC,XSC,YSC,IX=IXR,JX=JXR,EPS=LEPS,DEBUG=LDBG)
        ENDIF
      IF ( LDBG ) &
      WRITE(*,'(A,2L2,2E24.16)') 'W3GFIJ_R8 - RELATIVE:',INGRID,FNCL,IXR,JXR
!
!-----Set in grid if point is within DCIN cell width distance of closest cell
      IF ( .NOT.INGRID .AND. FNCL ) THEN
          DD = HALF + LDCIN
          INGRID = ABS(IXR-HALF).LE.DD .AND. ABS(JXR-HALF).LE.DD
        END IF
!
!-----Compute absolute index space location
      IX = IS(1)+IXR;  JX = JS(1)+JXR;
      IF ( LDBG ) &
      WRITE(*,'(A,2L2,2E24.16)') 'W3GFIJ_R8 - ABSOLUTE:',INGRID,FNCL,IX,JX

      END FUNCTION W3GFIJ_R8
!/
!/ End of W3GFIJ ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3GRMP( GSU, XTIN, YTIN, IS, JS, RW, EPS, &
!/                     DCIN, MASK, MSKC, NNBR, DEBUG ) RESULT(INGRID)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute remapping for target point ( xtin, ytin ) from source grid
!     associated with the input grid search utility object (GSU).
!     The indices of the source points used for remapping are returned in
!     is(1:4) and js(1:4).  The remapping weights are returned in rw(1:4).
!
!  2. Method :
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INGRID  Log.   O   Logical flag indicating if target point lies
!                          within the source grid domain.
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       GSU     Type   I   Grid-search-utility object.
!       XTIN    Real   I   X-coordinate of target point.
!       YTIN    Real   I   Y-coordinate of target point.
!       IS,JS   I.A.   O   (I,J) indices of vertices of enclosing grid cell.
!       RW      R.A.   O   Array of interpolation weights.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check if
!                          target point is in domain and for point coincidence.
!       DCIN    Real   I   OPTIONAL distance outside of source grid in
!                          units of cell width to treat target point as
!                          inside the source grid.  Default is 0.
!       MASK    L.A.   I   OPTIONAL logical mask for source grid.
!       MSKC    Int.   O   OPTIONAL output integer parameter indicating how
!                          the enclosing cell is masked.  Possible values
!                          are MSKC_NONE, MSKC_PART and MSKC_FULL.
!                          MSKC is required when MASK is specified.
!       NNBR    Int.   I/O OPTIONAL integer parameter indicating the number
!                          of nearest-neighbor non-masked points used for
!                          distance-weighted averaging.
!                          Input:  Requested number of nearest-neighbor
!                                  non-masked points (0 < NNBR <= 4).
!                          Output: Actual number of nearest-neighbor
!                                  non-masked points used.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!     - Check on previous initialization of grid search utility object.
!     - Check on appropriate input of optional arguments.
!
!  7. Remarks :
!
!  8. Structure :
!
!     -----------------------------------------------------------------
!      1.  Test input
!      2.  Initialize search
!      3.  Find enclosing cell and compute remapping weights
!          - if enclosing cell does not includes a pole, then
!            compute bilinear remapping
!          - if enclosing cell includes a pole, then
!            compute distance weighted remapping
!      4.  Handle case of target point located within a partially masked cell.
!      5.  Handle case of target point located within a fully masked cell.
!     -----------------------------------------------------------------
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GRMP_R4( GSU, XTIN, YTIN, IS, JS, RW, EPS, &
                          DCIN, MASK, MSKC, NNBR, DEBUG ) RESULT(INGRID)
!     Single precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(4), INTENT(IN)     :: XTIN
      REAL(4), INTENT(IN)     :: YTIN
      INTEGER, INTENT(OUT)    :: IS(4)
      INTEGER, INTENT(OUT)    :: JS(4)
      REAL(4), INTENT(OUT)    :: RW(4)
      REAL(4), INTENT(IN)   , OPTIONAL :: EPS
      REAL(4), INTENT(IN)   , OPTIONAL :: DCIN
      LOGICAL, INTENT(IN)   , OPTIONAL :: MASK(:,:)
      INTEGER, INTENT(OUT)  , OPTIONAL :: MSKC
      INTEGER, INTENT(INOUT), OPTIONAL :: NNBR
      LOGICAL, INTENT(IN)   , OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, RW8(4), EPS8, DCIN8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GRMP_R4')
!
!-----set inputs
      XT8 = XTIN; YT8 = YTIN;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
      IF ( PRESENT(DCIN) ) THEN
          DCIN8 = DCIN
        ELSE
          DCIN8 = ZERO
        END IF
!
!-----call double precision method
      INGRID = W3GRMP( GSU, XT8, YT8, IS, JS, RW8, &
                       EPS=EPS8, DCIN=DCIN8, &
                       MASK=MASK, MSKC=MSKC, NNBR=NNBR, DEBUG=DEBUG )
!
!-----set outputs
      RW = RW8

      END FUNCTION W3GRMP_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3GRMP_R8( GSU, XTIN, YTIN, IS, JS, RW, EPS, &
                          DCIN, MASK, MSKC, NNBR, DEBUG ) RESULT(INGRID)
!     Double precision interface
      LOGICAL                 :: INGRID
      TYPE(T_GSU), INTENT(IN) :: GSU
      REAL(8), INTENT(IN)     :: XTIN
      REAL(8), INTENT(IN)     :: YTIN
      INTEGER, INTENT(OUT)    :: IS(4)
      INTEGER, INTENT(OUT)    :: JS(4)
      REAL(8), INTENT(OUT)    :: RW(4)
      REAL(8), INTENT(IN)   , OPTIONAL :: EPS
      REAL(8), INTENT(IN)   , OPTIONAL :: DCIN
      LOGICAL, INTENT(IN)   , OPTIONAL :: MASK(:,:)
      INTEGER, INTENT(OUT)  , OPTIONAL :: MSKC
      INTEGER, INTENT(INOUT), OPTIONAL :: NNBR
      LOGICAL, INTENT(IN)   , OPTIONAL :: DEBUG

!     Local parameters
      REAL(8), PARAMETER :: BIG = 1D16
      REAL(8), PARAMETER :: SMALL = 1D-6
      REAL(8) :: LEPS
      LOGICAL :: LDBG, FNCL, POLE
      INTEGER :: I, J, K, L, IB, JB, IBC, JBC
      LOGICAL :: M, MSK(4)
      INTEGER :: LVL, N, NS, ICC, JCC
      REAL(8) :: XT, YT, XS(4), YS(4), DW(4)
      REAL(8) :: XTC, YTC, XSC(4), YSC(4)
      REAL(8) :: LDCIN, IXR, JXR, X, Y, D(4), DD, DMIN, DSUM, LON0, LAT0
      LOGICAL :: IJG, LLG, LCLO
      INTEGER :: ICLO, GKIND
      INTEGER :: LBX, LBY, UBX, UBY, NX, NY
      REAL(4), POINTER :: XG4(:,:), YG4(:,:)
      REAL(8), POINTER :: XG8(:,:), YG8(:,:)
      TYPE(T_NNS), POINTER :: NNP
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GRMP_R8')
!
! -------------------------------------------------------------------- /
! 1.  Test input
!
      IF ( .NOT.ASSOCIATED(GSU%PTR) ) THEN
          WRITE(0,'(/2A/)') 'W3GRMP_R8 ERROR -- ', &
          'grid search utility object not created'
          CALL EXTCDE (1)
        END IF
!
      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GRMP_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
!
      IF ( PRESENT(DCIN) ) THEN
          IF ( DCIN .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3GRMP_R4 ERROR -- ', &
              'DCIN parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LDCIN = DCIN
        ELSE
          LDCIN = ZERO
        END IF
!
      IF ( PRESENT(MASK) ) THEN
          IF ( .NOT.PRESENT(MSKC) ) THEN
              WRITE(0,'(/2A/)') 'W3GRMP_R8 ERROR -- ', &
              'MSKC must be specified with MASK'
              CALL EXTCDE (1)
            END IF
          IF ( PRESENT(NNBR) ) THEN
              IF ( .NOT.ASSOCIATED(GSU%PTR%NNP) ) THEN
                  WRITE(0,'(/3A/)') 'W3GRMP_R8 ERROR -- ', &
                  'MASK and NNBR input specified, ', &
                  'but grid point-search object not created'
                  CALL EXTCDE (1)
                END IF
              IF ( NNBR .LE. 0 .OR. NNBR .GT. 4 ) THEN
                  WRITE(0,'(/2A/)') 'W3GRMP_R8 ERROR -- ', &
                  'NNBR must be >= 1 AND <= 4'
                  CALL EXTCDE (1)
                END IF
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Initialize search
!
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!  Local pointers to grid search utility object data
      IJG = GSU%PTR%IJG
      LLG = GSU%PTR%LLG
      ICLO = GSU%PTR%ICLO
      LCLO = GSU%PTR%LCLO
      GKIND = GSU%PTR%GKIND
      LBX = GSU%PTR%LBX;  LBY = GSU%PTR%LBY;
      UBX = GSU%PTR%UBX;  UBY = GSU%PTR%UBY;
      NX = GSU%PTR%NX;  NY = GSU%PTR%NY;
      IF ( GKIND.EQ.4 ) THEN
          XG4 => GSU%PTR%XG4;  YG4 => GSU%PTR%YG4;
        ELSE
          XG8 => GSU%PTR%XG8;  YG8 => GSU%PTR%YG8;
        END IF
      NNP => GSU%PTR%NNP
!
      RW = ZERO;
!
      XT = XTIN;  YT = YTIN;
      IF ( LDBG ) WRITE(*,'(/A,2E24.16)') 'W3GRMP_R8 - TARGET POINT:',XT,YT
!
! -------------------------------------------------------------------- /
! 3.  Find enclosing cell and compute remapping
!
      FNCL = LDCIN .GT. ZERO
      INGRID = W3GFCL(GSU,XT,YT,IS,JS,XS,YS,POLE=POLE,EPS=LEPS,FNCL=FNCL,DEBUG=LDBG)
      IF ( .NOT.INGRID .AND. .NOT.FNCL ) RETURN
!
!-----Compute remapping
      LON0 = SUM(XS)/FOUR; LAT0 = SUM(YS)/FOUR;
      IF ( D90-ABS(LAT0).GT.NEAR_POLE ) THEN
!---------non-pole cell: compute remapping using (lon,lat)
          CALL W3RMBL(XT,YT,XS,YS,IX=IXR,JX=JXR,RW=DW,EPS=LEPS,DEBUG=LDBG)
        ELSE
!---------pole cell: compute remapping using stereographic projection
          CALL W3SPLX(LON0,LAT0,ZERO,XT,YT,XTC,YTC)
          DO I=1,4
              CALL W3SPLX(LON0,LAT0,ZERO,XS(I),YS(I),XSC(I),YSC(I))
            END DO
          CALL W3RMBL(XTC,YTC,XSC,YSC,IX=IXR,JX=JXR,RW=DW,EPS=LEPS,DEBUG=LDBG)
        ENDIF
      RW = DW
      IF ( LDBG ) THEN
          WRITE(*,'(A,2E24.16)') 'W3GRMP_R8 - REMAP (TGT):',XT,YT
          DO L=1,4
              WRITE(*,'(A,3I6,E24.16)') 'W3GRMP_R8 - REMAP (SRC):', &
              L,IS(L),JS(L),DW(L)
            END DO
        END IF !LDBG
!
!-----Set in grid if point is within DCIN cell width distance of closest cell
      IF ( .NOT.INGRID .AND. FNCL ) THEN
          DD = HALF + LDCIN
          INGRID = ABS(IXR-HALF).LE.DD .AND. ABS(JXR-HALF).LE.DD
        END IF
      IF ( .NOT.INGRID ) RETURN
!
      IF ( .NOT.PRESENT(MASK) ) RETURN
!
! -------------------------------------------------------------------- /
! 4.  Handle case of target point located within a partially masked cell.
!
!-----copy cell mask values according to array ordering
      IF ( IJG ) THEN
          DO L=1,4
              MSK(L) = MASK(IS(L),JS(L))
            END DO
        ELSE
          DO L=1,4
              MSK(L) = MASK(JS(L),IS(L))
            END DO
        END IF
!
!-----adjust weights for a partially masked cell
      DSUM = ZERO
      NS = 4
      DO L=1,4
          IF ( MSK(L) ) THEN
              NS = NS - 1
              DW(L) = ZERO
            END IF
          DSUM = DSUM + DW(L)
        END DO
      IF ( NS .EQ. 4 ) THEN
          MSKC = MSKC_NONE
          RETURN
        END IF
      IF ( NS .GT. 0 .AND. DSUM .GT. SMALL ) THEN
          DW = DW / DSUM
          RW = DW
          IF ( LDBG ) &
          WRITE(*,'(A,2E24.16,4(2I6,E24.16))') &
          'W3GRMP_R8 - PARTIAL MASKED CELL:', &
          XT,YT,(IS(L),JS(L),DW(L),L=1,4)
          MSKC = MSKC_PART
          RETURN
        ELSE
          MSKC = MSKC_FULL
          IF ( .NOT.PRESENT(NNBR) ) RETURN
        END IF
!
! -------------------------------------------------------------------- /
! 5.  Handle case of target point located within a fully masked cell.
!
!  Choose closest point in enclosing land cell to be the central point
      DMIN = BIG
      DO L=1,4
          DD = W3DIST(LLG,XT,YT,XS(L),YS(L))
          IF ( DD .LT. DMIN ) THEN
              DMIN = DD;  ICC = IS(L);  JCC = JS(L);
            END IF
        END DO !L
!
!  Search nearest-neighbor source points for closest nnbr un-masked
!  points and compute distance-weighted average remapping.
      IF ( LDBG ) &
      WRITE(*,'(A,2I6)') &
      'W3GRMP_R8 - BEGIN POINT NNBR SEARCH:',ICC,JCC
      NS = 0;  D(:) = BIG;
      LEVEL_LOOP: DO LVL=0,NNP%NLVL
          NNBR_LOOP: DO N=NNP%N1(LVL),NNP%N2(LVL)
              I = ICC + NNP%DI(N);  J = JCC + NNP%DJ(N);
              IF ( ICLO.EQ.ICLO_NONE ) THEN
                  IF ( I.LT.LBX .OR. I.GT.UBX ) CYCLE NNBR_LOOP
                  IF ( J.LT.LBY .OR. J.GT.UBY ) CYCLE NNBR_LOOP
                END IF
              IF ( MOD(ICLO,2).EQ.0 ) THEN
                  IF ( I .LT. LBX ) I = I + NX
                  IF ( I .GT. UBX ) I = I - NX
                END IF
              IF ( MOD(ICLO,3).EQ.0 ) THEN
                  IF ( J .LT. LBY ) J = J + NY
                  IF ( J .GT. UBY ) J = J - NY
                END IF
              IF ( ICLO.EQ.ICLO_TRPL ) THEN
                  IF ( J .GT. UBY ) THEN
                      J = UBY
                      I = NX - MOD(I-1,NX)
                    END IF
                END IF
              IF ( IJG ) THEN
                  M = MASK(I,J)
                ELSE
                  M = MASK(J,I)
                END IF
              IF ( LDBG ) &
              WRITE(*,'(A,4I6,1L6)') &
              'W3GRMP_R8 - POINT NNBR SEARCH:',LVL,N,I,J,M
!-------------if masked point, then skip
              IF ( M ) CYCLE NNBR_LOOP
!-------------compute distance
              IF ( IJG ) THEN
                  IF ( GKIND.EQ.4 ) THEN
                      X = XG4(I,J);  Y = YG4(I,J);
                    ELSE
                      X = XG8(I,J);  Y = YG8(I,J);
                    END IF
                ELSE
                  IF ( GKIND.EQ.4 ) THEN
                      X = XG4(J,I);  Y = YG4(J,I);
                    ELSE
                      X = XG8(J,I);  Y = YG8(J,I);
                    END IF
                END IF
              DD = W3DIST(LLG,XT,YT,X,Y)
!-------------still need nnbr points
              IF ( NS .LT. NNBR ) THEN
!-----------------add to list
                  NS = NS + 1
                  IS(NS) = I;  JS(NS) = J;  D(NS) = DD;
!-----------------once list is full sort according to increasing distance
                  IF ( NS .EQ. NNBR ) CALL W3SORT(NS,IS,JS,D)
!---------------we have found nnbr points
                ELSE !list is full
!-----------------insert into list if the newest point is closer
                  CALL W3ISRT(I,J,DD,NS,IS,JS,D)
                END IF !list is full
              IF ( LDBG ) &
              WRITE(*,'(A,I2,I3,I6,4(2I6,E24.16))') &
              'W3GRMP_R8 - POINT NNBR LIST:', &
              LVL,N,NS,(IS(L),JS(L),D(L),L=1,NS)
            END DO NNBR_LOOP
!---------if we have found nnbr_rqd points, then exit the search
          IF ( NS .EQ. NNBR ) EXIT LEVEL_LOOP
        END DO LEVEL_LOOP
      NNBR = NS
!
!  If zero unmasked points found, then return nnbr=0 as error indicator
      IF ( NNBR .EQ. 0 ) RETURN
!
!  Compute distance-weighted remapping for nnbr points
      DSUM = ZERO
      DO L=1,NNBR
          DSUM = DSUM + ONE/(D(L)+SMALL)
        END DO
      DW(1:NNBR) = ONE/(D(1:NNBR)+SMALL)/DSUM
      RW = DW
      IF ( LDBG ) THEN
          WRITE(*,'(A,2E24.16,I6)') &
          'W3GRMP_R8 - FULLY MASKED CELL (TGT):',XT,YT,NNBR
          DO L=1,NNBR
              WRITE(*,'(A,3I6,E24.16)') &
              'W3GRMP_R8 - FULLY MASKED CELL (SRC):', &
              L,IS(L),JS(L),DW(L)
            END DO
        END IF !LDBG

      END FUNCTION W3GRMP_R8
!/
!/ End of W3GRMP ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3CKCL( LLG, XT, YT, NS, XS, YS, POLE, EPS, DEBUG ) &
!/    RESULT(INCELL)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Check if point lies within grid cell.
!
!  2. Method :
!
!     Calculates cross products for vertex to vertex (i.e. cell side) 
!     vs vertex to target. If all cross products have the same sign,
!     the point is considered to be within the cell. Since they can 
!     be "all positive" *or* "all negative", there are no pre-conditions
!     that the order of specification of the vertices be clockwise vs.
!     counter-clockwise geographically.  The logical variable POLE is
!     set to true if the grid cell includes a pole.
!     
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       INCELL  Log.   O   Logical flag indicating point is in the cell
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       LLG     Log.   I   Logical flag indicating the coordinate system:
!                          T = spherical lat/lon (degrees) and F = Cartesian.
!       XT      Real   I   X-coordinate of target point.
!       YT      Real   I   Y-coordinate of target point.
!       XS      R.A.   I   X-coordinates of source cell vertices.
!       YS      R.A.   I   Y-coordinates of source cell vertices.
!       POLE    Log.   O   OPTIONAL output logical flag to indicate
!                          the source cell contains a pole.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check
!                          for point coincidence.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - For LL grids, this method assumes that the longitudes of point
!       and grid cell vertices lie in the same range (i.e., both in [0:360]
!       or [-180:180]).  If the longitudes are not in the same range, then
!       this method may result in a false positive.  The burden is upon the
!       caller to ensure that the longitude range of the point is the same
!       as that of the grid cell vertices.
!     - If enclosing cell includes a branch cut, then the coordinates of
!       of the cell vertices AND the target point will be adjusted so
!       that the branch cut is shifted 180 degrees.
!     - If the enclosing cell includes a pole, then the cross-product check
!       is performed using coordinates in a stereographic projection.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3CKCL_R4( LLG, XT, YT, NS, XS, YS, POLE, EPS, DEBUG ) &
      RESULT(INCELL)
!     Single precision interface
      LOGICAL                :: INCELL
      LOGICAL, INTENT(IN)    :: LLG
      REAL(4), INTENT(INOUT) :: XT, YT
      INTEGER, INTENT(IN)    :: NS
      REAL(4), INTENT(INOUT) :: XS(NS), YS(NS)
      LOGICAL, INTENT(OUT)   :: POLE
      REAL(4), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, XS8(NS), YS8(NS), EPS8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3CKCL_R4')
!
!-----set inputs
      XT8 = XT;  XS8 = XS;
      YT8 = YT;  YS8 = YS;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
!
!-----call double precision method
      INCELL = W3CKCL( LLG, XT8, YT8, NS, XS8, YS8, POLE, &
                       EPS=EPS8, DEBUG=DEBUG )
!
!-----return branch cut shifted coordinates
      XT = XT8;  XS = XS8;

      END FUNCTION W3CKCL_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3CKCL_R8( LLG, XT, YT, NS, XS, YS, POLE, EPS, DEBUG ) &
      RESULT(INCELL)
!     Double precision interface
      LOGICAL                :: INCELL
      LOGICAL, INTENT(IN)    :: LLG
      REAL(8), INTENT(INOUT) :: XT, YT
      INTEGER, INTENT(IN)    :: NS
      REAL(8), INTENT(INOUT) :: XS(NS), YS(NS)
      LOGICAL, INTENT(OUT)   :: POLE
      REAL(8), INTENT(IN), OPTIONAL :: EPS
      LOGICAL, INTENT(IN), OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: LEPS
      LOGICAL :: LDBG, LSBC, BCUT
      INTEGER :: I, J, K, N
      REAL(8) :: XXT, YYT, XXS(NS), YYS(NS)
      REAL(8) :: XCT, YCT, XCS(NS), YCS(NS)
      REAL(8) :: V1X, V1Y, V2X, V2Y, S90, LON0, LAT0
      REAL(8) :: CROSS
      REAL(8) :: SIGN1
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3CKCL_R8')

      INCELL = .TRUE.
!
!-----must have >= 3 points to be a cell
      IF ( NS .LT. 3 ) THEN
          INCELL = .FALSE.
          RETURN
        END IF
!
      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3CKCL_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!-----set local copies
      XXT = XT;  XXS = XS;
      YYT = YT;  YYS = YS;
!
!-----check if cell includes a pole or branch cut
      IF ( LLG ) THEN
          N = 0
!---------count longitudinal branch cut crossings
          DO I=1,NS
              J = MOD(I,NS) + 1
              IF ( ABS(XXS(J)-XXS(I)) .GT. D180 ) N = N + 1
            END DO
!---------multiple longitudinal branch cut crossing => cell includes branch cut
          BCUT = N.GT.1
!---------single longitudinal branch cut crossing
!         or single vertex at 90 degrees => cell includes pole
          POLE = N.EQ.1 .OR. COUNT(ABS(D90-ABS(YYS)).LE.LEPS).EQ.1
        ELSE
          POLE = .FALSE.
          BCUT = .FALSE.
        END IF
!
!-----shift branch cut if necessary
      IF ( BCUT ) THEN
          IF ( MINVAL(XXS) .GE. ZERO ) THEN
              WHERE ( XXS .GT. D180 ) XXS = XXS - D360
              IF ( XXT .GT. D180 ) XXT = XXT - D360
            ELSE
              WHERE ( XXS .LT. ZERO ) XXS = XXS + D360
              IF ( XXT .LT. ZERO ) XXT = XXT + D360
            END IF
          IF ( LDBG ) THEN
              WRITE(*,'(A)') 'W3CKCL_R8 - CELL INCLUDES A BRANCH CUT'
              WRITE(*,'(A,2E24.16,4(/A,1I1,A,2E24.16))') &
              'W3CKCL_R8 - SHIFT BRANCH CUT:',XXT,YYT, &
              ('          CORNER(',K,'):',XXS(K),YYS(K),K=1,4)
            END IF
        END IF
!
!-----check for coincidence with a cell vertex
      DO I=1,NS
!---------if target point is coincident a cell vertex, then
!         flag as in cell and return
          IF ( ABS(XXT-XXS(I)).LE.LEPS .AND. ABS(YYT-YYS(I)).LE.LEPS ) THEN
              IF ( LDBG ) &
              WRITE(*,'(A,I1,A,2E24.16)') &
              'W3CKCL_R8 - COINCIDENT WITH CORNER(',I,'): ', &
              ABS(XXT-XXS(I)),ABS(YYT-YYS(I))
!-------------return branch cut shifted coordinates
              IF ( BCUT ) THEN
                  XT = XXT;  XS = XXS;
                END IF
              INCELL = .TRUE.
              RETURN
            END IF
        END DO
!
!-----handle cell that includes a pole
      IF ( POLE ) THEN
!---------perform cross-product check for each subcell
          IF ( LDBG ) &
          WRITE(*,'(A)') 'W3CKCL_R8 - CELL INCLUDES A POLE'
          S90 = D90; IF ( MAXVAL(YS).LT.ZERO ) S90 = -D90;
          SUBCELL_LOOP: DO I=1,NS
              LSBC = .TRUE.
              J = MOD(I,NS) + 1
              DO K=1,4
                  SELECT CASE (K)
                    CASE (1)
!---------------------vector from (xi,yi) to (xj,yj)
                      V1X = XXS(J) - XXS(I)
                      V1Y = YYS(J) - YYS(I)
!---------------------vector from (xi,yi) to (xt,yt)
                      V2X = XXT    - XXS(I)
                      V2Y = YYT    - YYS(I)
                    CASE (2)
!---------------------vector from (xj,yj) to (xj,90)
                      V1X = XXS(J) - XXS(J)
                      V1Y = S90    - YYS(J)
!---------------------vector from (xj,yj) to (xt,yt)
                      V2X = XXT    - XXS(J)
                      V2Y = YYT    - YYS(J)
                    CASE (3)
!---------------------vector from (xj,90) to (xi,90)
                      V1X = XXS(I) - XXS(J)
                      V1Y = S90    - S90
!---------------------vector from (xj,90) to (xt,yt)
                      V2X = XXT    - XXS(J)
                      V2Y = YYT    - S90
                    CASE (4)
!---------------------vector from (xi,90) to (xi,yi)
                      V1X = XXS(I) - XXS(I)
                      V1Y = YYS(I) - S90
!---------------------vector from (xi,90) to (xt,yt)
                      V2X = XXT    - XXS(I)
                      V2Y = YYT    - S90
                    END SELECT
!-----------------check for longitudinal branch cut crossing
                  IF ( ABS(V1X) .GT. D180 ) THEN
                      V1X = V1X - SIGN(D360,V1X)
                    END IF
                  IF ( ABS(V2X) .GT. D180 ) THEN
                      V2X = V2X - SIGN(D360,V2X)
                    END IF
!-----------------cross product
                  CROSS = V1X*V2Y - V1Y*V2X
!-----------------handle point that lies exacly on side or zero length side
                  IF ( ABS(CROSS) .LT. LEPS ) CROSS = ZERO
                  IF ( LDBG ) &
                  WRITE(*,'(A,3(I1,A),5E24.16)') 'W3CKCL_R8 - CROSS(', &
                  I,',',J,',',K,'):',V1X,V1Y,V2X,V2Y,CROSS
!-----------------if sign of cross product is not "unanimous" among the
!                 subcell sides, then target is outside the subcell
                  IF ( K .EQ. 1 ) THEN
                      SIGN1 = SIGN(ONE,CROSS)
                    ELSE
                      IF ( SIGN(ONE,CROSS) .NE. SIGN1 ) THEN
                          LSBC = .FALSE.
                          CYCLE SUBCELL_LOOP
                        END IF
                    END IF
                END DO !K
                IF ( LSBC ) RETURN
            END DO SUBCELL_LOOP
          INCELL = .FALSE.
          RETURN
        ELSE
!---------use input coordinates
          XCT = XXT;  YCT = YYT;
          XCS = XXS;  YCS = YYS;
        END IF !POLE
!
!-----perform cross-product cell check
      DO I=1,NS
          J = MOD(I,NS) + 1
!---------vector from (xi,yi) to (xj,yj)
          V1X = XCS(J) - XCS(I)
          V1Y = YCS(J) - YCS(I)
!---------vector from (xi,yi) to (xt,yt)
          V2X = XCT    - XCS(I)
          V2Y = YCT    - YCS(I)
!---------cross product
          CROSS = V1X*V2Y - V1Y*V2X
!---------handle point that lies exacly on side or zero length side
          IF ( ABS(CROSS) .LT. LEPS ) CROSS = ZERO
          IF ( LDBG ) &
          WRITE(*,'(A,2(I1,A),5E24.16)') 'W3CKCL_R8 - CROSS(', &
          I,',',J,'):',V1X,V1Y,V2X,V2Y,CROSS
!---------if sign of cross product is not "unanimous" among the cell sides,
!         then target is outside the cell
          IF ( I .EQ. 1 ) THEN
              SIGN1 = SIGN(ONE,CROSS)
            ELSE
              IF ( SIGN(ONE,CROSS) .NE. SIGN1 ) THEN
                  INCELL = .FALSE.
                  RETURN
                END IF
            END IF
        END DO
!
!-----return branch cut shifted coordinates
      IF ( BCUT ) THEN
          XT = XXT;  XS = XXS;
        END IF

      END FUNCTION W3CKCL_R8
!/
!/ End of W3CKCL ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3RMBL( XT, YT, XS, YS, RW, IX, JX, EPS, DEBUG )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Bilinear remapping for target point ( xt, yt ) in a cell defined
!     by the source points ( xs(1:4), ys(1:4) ).  Remapping weights are
!     returned in rw(1:4).  It is the caller's responsibility to ensure
!     that the target point is located within the input cell and that the
!     cell corner points are properly defined.
!
!          (xs4,ys4)            (xs3,ys3)
!               _____________________
!              /                    /
!             /        x           /
!            /   (xtin,ytin)      /
!           /                    /
!          /____________________/
!    (xs1,ys1)             (xs2,ys2)
!
!     In spherical coordinates it is assumed that the longitude range of
!     the target point is the same as that of the cell vertices.  It is
!     also assumed that the cell does not includes a branch cut.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       XT      Real   I   X-coordinate of target point.
!       YT      Real   I   Y-coordinate of target point.
!       XS      R.A.   I   X-coordinates of source cell vertices.
!       YS      R.A.   I   Y-coordinates of source cell vertices.
!       RW      R.A.   O   OPTIONAL bilinear remapping weights.
!       IX      Real   O   OPTIONAL relative x-coordinate of target point.
!       IY      Real   O   OPTIONAL relative y-coordinate of target point.
!       EPS     Real   I   OPTIONAL small non-zero tolerance used to check
!                          for point coincidence.
!       DEBUG   Log.   I   OPTIONAL logical flag to turn on debug mode.
!                          Default is FALSE.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - Implementation is based on SCRIP.
!     - In the case of spherical coordinates, the method results in
!       bogus weights if enclosing cell contains a pole.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3RMBL_R4( XT, YT, XS, YS, RW, IX, JX, EPS, DEBUG )
!     Single precision interface
      REAL(4), INTENT(IN)   :: XT
      REAL(4), INTENT(IN)   :: YT
      REAL(4), INTENT(IN)   :: XS(4)
      REAL(4), INTENT(IN)   :: YS(4)
      REAL(4), INTENT(OUT), OPTIONAL :: RW(4)
      REAL(4), INTENT(OUT), OPTIONAL :: IX
      REAL(4), INTENT(OUT), OPTIONAL :: JX
      REAL(4), INTENT(IN),  OPTIONAL :: EPS
      LOGICAL, INTENT(IN) , OPTIONAL :: DEBUG

!     Local parameters
      REAL(8) :: XT8, YT8, XS8(4), YS8(4), RW8(4), IX8, JX8, EPS8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3RMBL_R4')
!
!-----set inputs
      XT8 = XT; YT8 = YT;
      XS8 = XS; YS8 = YS;
      IF ( PRESENT(EPS) ) THEN
          EPS8 = EPS
        ELSE
          EPS8 = EPS_DEFAULT
        END IF
!
!-----call double precision method
      CALL W3RMBL( XT8, YT8, XS8, YS8, RW=RW8, IX=IX8, JX=JX8, &
                   EPS=EPS8, DEBUG=DEBUG )
!
!-----set outputs
      IF ( PRESENT(RW) ) RW = RW8
      IF ( PRESENT(IX) ) IX = IX8
      IF ( PRESENT(JX) ) JX = JX8

      END SUBROUTINE W3RMBL_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3RMBL_R8( XT, YT, XS, YS, RW, IX, JX, EPS, DEBUG )
!     Double precision interface
      REAL(8), INTENT(IN)   :: XT
      REAL(8), INTENT(IN)   :: YT
      REAL(8), INTENT(IN)   :: XS(4)
      REAL(8), INTENT(IN)   :: YS(4)
      REAL(8), INTENT(OUT), OPTIONAL :: RW(4)
      REAL(8), INTENT(OUT), OPTIONAL :: IX
      REAL(8), INTENT(OUT), OPTIONAL :: JX
      REAL(8), INTENT(IN),  OPTIONAL :: EPS
      LOGICAL, INTENT(IN) , OPTIONAL :: DEBUG

!     Local parameters
      INTEGER, PARAMETER :: MAX_ITER = 10
      REAL(8), PARAMETER :: CONVERGE = 1D-6
      REAL(8) :: LEPS
      LOGICAL :: LDBG
      INTEGER :: K, ITER
      REAL(8) :: DXT, DX1, DX2, DX3, DXP, DYT, DY1, DY2, DY3, DYP
      REAL(8) :: IGUESS, JGUESS, MAT1, MAT2, MAT3, MAT4, DELI, DELJ, DET
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3RMBL_R8')

      IF ( PRESENT(EPS) ) THEN
          IF ( EPS .LT. ZERO ) THEN
              WRITE(0,'(/2A/)') 'W3RMBL_R8 ERROR -- ', &
              'EPS parameter must be >= 0'
              CALL EXTCDE (1)
            END IF
          LEPS = EPS
        ELSE
          LEPS = EPS_DEFAULT
        END IF
      IF ( PRESENT(DEBUG) ) THEN
          LDBG = DEBUG
        ELSE
          LDBG = .FALSE.
        END IF
!
!-----handle point coincident with a cell vertex
      DO K=1,4
          IF ( ABS(XT-XS(K)).LE.LEPS .AND. ABS(YT-YS(K)).LE.LEPS ) THEN
              SELECT CASE ( K )
                CASE ( 1 )
                  IGUESS = ZERO;  JGUESS = ZERO;
                CASE ( 2 )
                  IGUESS =  ONE;  JGUESS = ZERO;
                CASE ( 3 )
                  IGUESS =  ONE;  JGUESS =  ONE;
                CASE ( 4 )
                  IGUESS = ZERO;  JGUESS =  ONE;
                END SELECT
              IF ( LDBG ) &
              WRITE(*,'(A,I3,4E24.16)') 'W3RMBL_R8 - COINCIDENT:', &
              K,ABS(XT-XS(K)),ABS(YT-YS(K)),IGUESS,JGUESS
              IF ( PRESENT(RW) ) THEN
                  RW(1) = (ONE-IGUESS)*(ONE-JGUESS)
                  RW(2) = IGUESS*(ONE-JGUESS)
                  RW(3) = IGUESS*JGUESS
                  RW(4) = (ONE-IGUESS)*JGUESS
                END IF
              IF ( PRESENT(IX) .AND. PRESENT(JX) ) THEN
                  IX = IGUESS
                  JX = JGUESS
                END IF
              RETURN
            END IF
        END DO
!
!-----set iteration parameters and initial guess
      IF ( PRESENT(RW) ) RW = ZERO
      IGUESS = HALF
      JGUESS = HALF
      DYT = YT    - YS(1)
      DY1 = YS(2) - YS(1)
      DY2 = YS(4) - YS(1)
      DY3 = YS(3) - YS(2) - DY2
      DXT = XT    - XS(1)
      DX1 = XS(2) - XS(1)
      DX2 = XS(4) - XS(1)
      DX3 = XS(3) - XS(2) - DX2

!-----iterate to find (i,j) for bilinear approximation
      ITER_LOOP: DO ITER=1,MAX_ITER
          DYP = DYT - DY1*IGUESS - DY2*JGUESS - DY3*IGUESS*JGUESS
          DXP = DXT - DX1*IGUESS - DX2*JGUESS - DX3*IGUESS*JGUESS
          MAT1 = DY1 + DY3*JGUESS
          MAT2 = DY2 + DY3*IGUESS
          MAT3 = DX1 + DX3*JGUESS
          MAT4 = DX2 + DX3*IGUESS
          DET = MAT1*MAT4 - MAT2*MAT3
          DELI = (DYP*MAT4 - MAT2*DXP)/DET
          DELJ = (MAT1*DXP - DYP*MAT3)/DET
          IF ( LDBG ) &
          WRITE(*,'(A,I3,4E24.16)') 'W3RMBL_R8 - ITER:', &
          ITER,IGUESS,JGUESS,DELI,DELJ
          IGUESS = IGUESS + DELI
          JGUESS = JGUESS + DELJ
          IF ( ABS(DELI) < CONVERGE .AND. &
               ABS(DELJ) < CONVERGE ) EXIT ITER_LOOP
        END DO ITER_LOOP

!-----compute weights
      IF ( PRESENT(RW) ) THEN
          RW(1) = (ONE-IGUESS)*(ONE-JGUESS)
          RW(2) = IGUESS*(ONE-JGUESS)
          RW(3) = IGUESS*JGUESS
          RW(4) = (ONE-IGUESS)*JGUESS
        END IF
      IF ( PRESENT(IX) .AND. PRESENT(JX) ) THEN
          IX = IGUESS
          JX = JGUESS
        END IF

!-----if max iteration count exceeded, then exit with error
      IF ( ITER .GT. MAX_ITER ) THEN
          WRITE(0,'(/A)') &
          'W3RMBL_R8 -- ERROR: exceeded max iteration count'
          WRITE(0,'(A,2E24.16)') 'W3RMBL_R8 - DEST POINT COORDS: ',XT,YT
          DO K=1,4
              WRITE(0,'(A,I1,A,2E24.16)') &
              'W3RMBL_R8 - SRC POINT ',K,': ',XS(K),YS(K)
            END DO
          WRITE(0,'(A,2E24.16)') 'W3RMBL_R8 - CURRENT I,J: ',IGUESS,JGUESS
          CALL EXTCDE (1)
        END IF !(ITER.LE.MAX_ITER)

      END SUBROUTINE W3RMBL_R8
!/
!/ End of W3RMBL ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3CGDM( IJG, LLG, ICLO, TILED, &
!/                       NP, NQ, LBI, UBI, LBO, UBO, X, Y, &
!/                       NFD, SPHERE, RADIUS, DX, DY, &
!/                       GPPC, GQQC, GPQC, GSQR, &
!/                       HPFC, HQFC, APPC, AQQC, APQC, &
!/                       DXDP, DYDP, DXDQ, DYDQ, &
!/                       DPDX, DPDY, DQDX, DQDY, &
!/                       COSA, COSC, SINC, ANGL, RC )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute curvilinear grid derivatives and metric.
!
!  2. Method :
!
!     Curvilinear grid is defined by the input coordinates as a function
!     of the (P,Q) index coordinates:
!
!         x = x(p,q),  y = y(p,q),  dp = dq = 1.
!  
!     When using spherical coordinates (llg=T) x = longitude and
!     y = latitude in degrees.  The optional sphere input (default is true)
!     controls whether or not the spherical coordinate metric is applied.
!     If sphere is true, then the spherical coordinate metric is applied
!     to the coordinate derivatives with respect to p & q.  In other words,
!
!         dx/dp <= d2r*radius*cos(y)*(dx/dp),
!         dx/dq <= d2r*radius*cos(y)*(dx/dq),
!         dy/dp <= d2r*radius*(dy/dp), and
!         dy/dq <= d2r*radius*(dy/dq).
!
!     The default radius is Rearth.
!
!     The covariant metric tensor components are
!
!         g_pp = (dx/dp)*(dx/dp) + (dy/dp)*(dy/dp),
!         g_qq = (dx/dq)*(dx/dq) + (dy/dq)*(dy/dq).
!         g_pq = (dx/dp)*(dx/dq) + (dy/dp)*(dy/dq),
!
!     The contravariant (associated) metric tensor components are
!
!         g^pp = (dp/dx)*(dp/dx) + (dp/dy)*(dp/dy),
!         g^qq = (dq/dx)*(dq/dx) + (dq/dy)*(dq/dy).
!         g^pq = (dp/dx)*(dq/dx) + (dp/dy)*(dq/dy),
!
!     The curvilinear scale factors are h_p = sqrt(g_pp) and h_q = sqrt(g_qq).
!     The square root of determinant of metric tensor is
!
!         sqrt(|g|) = sqrt( g_pp*g_qq - g_pq^2 )
!                   = (dx/dp)(dy/dq) - (dx/dq)(dy/dp)
!                   = h_p*h_q*sqrt(sin(alpha))
!                   = cell area.
!
!     The curvilinear derivatives are computed as
!
!         dp/dx =  (1/sqrt(g))*(dy/dq),
!         dp/dy = -(1/sqrt(g))*(dx/dq),
!         dq/dx = -(1/sqrt(g))*(dy/dp),
!         dq/dy =  (1/sqrt(g))*(dx/dp).
!
!     Orthogonality of grid can be checked by computing angle between the
!     curvilinear coordinate unit vectors:
!
!         cos(alpha) = g_pq/(h_p*h_q) = uvec_p \dot uvec_q,
!
!     where
!
!         uvec_p = (1/h_p)*(dx/dp)*uvec_x + (1/h_p)*(dy/dp)*uvec_y,
!         uvec_q = (1/h_q)*(dx/dq)*uvec_x + (1/h_q)*(dy/dq)*uvec_y.
!  
!     The local cell rotation angle is (assuming orthogonal):
!
!         cos(theta) = (1/h_p)*dx/dp,
!         sin(theta) = (1/h_q)*dy/dp,
!         theta      = atan2(dy/dp,dx/dp).
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       IJG     Log.   I   Logical flag indicating ordering of input
!                          coord. arrays: T = (NP,NQ) and F = (NP,NQ)
!       LLG     Log.   I   Spherical coordinate (lon,lat) flag
!       ICLO    Int.   I   Parameter indicating type of index space closure
!       TILED   Log.   I   Logical flag indicating that input arrays are tiled
!                          with halos of width >= NFD/2
!       NP      Int.   I   Range of P index coordinate: P in [1,NP]
!       NQ      Int.   I   Range of Q index coordinate: Q in [1,NQ]
!       LBI     I.A.   I   Lower-bound of  input arrays, DIMENSION(2)
!       UBI     I.A.   I   Upper-bound of  input arrays, DIMENSION(2)
!       LBO     I.A.   I   Lower-bound of output arrays, DIMENSION(2)
!       UBO     I.A.   I   Upper-bound of output arrays, DIMENSION(2)
!       X       R.A.   I   Gridded X-coordinates, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       Y       R.A.   I   Gridded Y-coordinates, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       NFD     Int.   I   OPTIONAL finite-difference order (even), Default is 2.
!       SPHERE  Log.   I   OPTIONAL apply spherical coord metric if LLG, Default is T
!       RADIUS  Real   I   OPTIONAL radius for sphere.  Default is REARTH
!       DX      Real   I   OPTIONAL constant spacing in x-direction
!       DY      Real   I   OPTIONAL constant spacing in y-direction
!       GPPC    R.A.   O   OPTIONAL g_pp,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       GQQC    R.A.   O   OPTIONAL g_qq,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       GPQC    R.A.   O   OPTIONAL g_pq,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       GSQR    R.A.   O   OPTIONAL sqrt(|g|),  DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       HPFC    R.A.   O   OPTIONAL h_p,        DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       HQFC    R.A.   O   OPTIONAL h_q,        DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       APPC    R.A.   O   OPTIONAL g^pp,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       AQQC    R.A.   O   OPTIONAL g^qq,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       APQC    R.A.   O   OPTIONAL g^pq,       DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DXDP    R.A.   O   OPTIONAL dx/dp,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DYDP    R.A.   O   OPTIONAL dy/dp,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DXDQ    R.A.   O   OPTIONAL dx/dq,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DYDQ    R.A.   O   OPTIONAL dy/dq,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DPDX    R.A.   O   OPTIONAL dp/dx,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DPDY    R.A.   O   OPTIONAL dp/dy,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DQDX    R.A.   O   OPTIONAL dq/dx,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DQDY    R.A.   O   OPTIONAL dq/dy,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       COSA    R.A.   O   OPTIONAL cos(alpha), DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       COSC    R.A.   O   OPTIONAL cos(theta), DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       SINC    R.A.   O   OPTIONAL sin(theta), DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       ANGL    R.A.   O   OPTIONAL theta,      DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       RC      Int.   O   OPTIONAL return code (!= 0 if error occurs)
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - The derivatives and metric will be computed using the constant
!       spacing DX and/or DY if they are specified.  DX & DY are assumed
!       to be in degrees when LLG = T.
!     - The grid derivatives (dx/dp, dy/dp, dx/dq, dy/dq) are computed
!       using a finite difference method.
!     - When LLG = T, the finite differences are done in a polar
!       stereographic projection.
!     - If RC is not provided and an error occurs, then the routine will
!       report error to stderr and attempt to abort the calling program.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3CGDM_R4( IJG, LLG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, X, Y, &
                            NFD, SPHERE, RADIUS, DX, DY, &
                            GPPC, GQQC, GPQC, GSQR, &
                            HPFC, HQFC, APPC, AQQC, APQC, &
                            DXDP, DYDP, DXDQ, DYDQ, &
                            DPDX, DPDY, DQDX, DQDY, &
                            COSA, COSC, SINC, ANGL, RC )
!     Single precision interface
      LOGICAL, INTENT(IN)   :: IJG
      LOGICAL, INTENT(IN)   :: LLG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(4), INTENT(IN)   :: X(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: Y(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(IN),  OPTIONAL :: NFD
      LOGICAL, INTENT(IN),  OPTIONAL :: SPHERE
      REAL(4), INTENT(IN),  OPTIONAL :: RADIUS
      REAL(4), INTENT(IN),  OPTIONAL :: DX, DY
      REAL(4), INTENT(OUT), OPTIONAL :: GPPC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: GQQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: GPQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: GSQR(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: HPFC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: HQFC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: APPC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: AQQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: APQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DXDP(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DYDP(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DXDQ(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DYDQ(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DPDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DPDY(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DQDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: DQDY(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: COSA(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: COSC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: SINC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT), OPTIONAL :: ANGL(LBO(1):UBO(1),LBO(2):UBO(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: ISTAT=0, N, I1, I2, P, Q
      LOGICAL :: SPHR
      REAL(8) :: R, FACX, FACY
      INTEGER, ALLOCATABLE :: K(:,:)
      REAL(8), ALLOCATABLE :: C(:,:)
      REAL(8) :: GPPCL, GQQCL, GPQCL
      REAL(8) :: GSQRL, HPFCL, HQFCL
      REAL(8) :: APPCL, AQQCL, APQCL
      REAL(8) :: DXDPL, DYDPL, DXDQL, DYDQL
      REAL(8) :: DPDXL, DPDYL, DQDXL, DQDYL
      REAL(8) :: COSAL, SINAL, COSTP, SINTP, COSCL, SINCL
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3CGDM_R4')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( PRESENT(NFD) ) THEN
          N = NFD
        ELSE
          N = NFD_DEFAULT
        END IF
      IF ( N.LE.0 .OR. MOD(N,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3CGDM ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      IF ( PRESENT(SPHERE) ) THEN
          SPHR = SPHERE
        ELSE
          SPHR = .TRUE.
        END IF

      IF ( PRESENT(RADIUS) ) THEN
          R = RADIUS
        ELSE
          R = REARTH
        END IF
      FACY = R*D2R
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      ALLOCATE ( K(0:N,0:N), C(0:N,0:N), STAT=ISTAT )
      IF ( ISTAT .NE. 0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'finite difference coeff allocation failed'
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
      CALL GET_FDW2( N, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute optional return quantities
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              IF ( PRESENT(DX) ) THEN
                  DXDPL = DX
                  DYDPL = ZERO
                ELSE
                  CALL DXYDP( N, K, C, IJG, LLG, ICLO, TILED, &
                              NP, NQ, LBI, UBI, P, Q, DXDPL, DYDPL, &
                              X4=X, Y4=Y, RC=ISTAT )
                  IF ( ISTAT .NE. 0 ) THEN
                      IF ( PRESENT(RC) ) THEN
                          RC = ISTAT
                          RETURN
                        ELSE
                          CALL EXTCDE (ISTAT)
                        END IF
                    END IF
                END IF
              IF ( PRESENT(DY) ) THEN
                  DXDQL = ZERO
                  DYDQL = DY
                ELSE
                  CALL DXYDQ( N, K, C, IJG, LLG, ICLO, TILED, &
                              NP, NQ, LBI, UBI, P, Q, DXDQL, DYDQL, &
                              X4=X, Y4=Y, RC=ISTAT )
                  IF ( ISTAT .NE. 0 ) THEN
                      IF ( PRESENT(RC) ) THEN
                          RC = ISTAT
                          RETURN
                        ELSE
                          CALL EXTCDE (ISTAT)
                        END IF
                    END IF
                END IF
              IF ( LLG .AND. SPHR ) THEN
                  FACX = FACY*COS(REAL(Y(I1,I2),8)*D2R)
                  DXDPL = DXDPL*FACX
                  DYDPL = DYDPL*FACY
                  DXDQL = DXDQL*FACX
                  DYDQL = DYDQL*FACY
                END IF
              GPPCL = DXDPL*DXDPL + DYDPL*DYDPL
              GQQCL = DXDQL*DXDQL + DYDQL*DYDQL
              GPQCL = DXDPL*DXDQL + DYDPL*DYDQL
              GSQRL = DXDPL*DYDQL - DXDQL*DYDPL
              IF ( GSQRL .LT. ZERO ) THEN
                  ISTAT = 1
                  WRITE(0,'(/1A,1A)') 'W3CGDM ERROR -- ', &
                  'input coordinates do not define a '// &
                  'right-handed coordinate system'
                  WRITE(0,'(1A,2A6,5A16)') 'W3CGDM ERROR --', &
                  'P','Q','GSQRL','DXDPL','DYDQL','DXDQL','DYDPL'
                  WRITE(0,'(1A,2I6,5E16.8/)') 'W3CGDM ERROR --', &
                  P,Q,GSQRL,DXDPL,DYDQL,DXDQL,DYDPL
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DPDXL = DYDQL/GSQRL
              DPDYL =-DXDQL/GSQRL
              DQDXL =-DYDPL/GSQRL
              DQDYL = DXDPL/GSQRL
              APQCL = DPDXL*DQDXL + DPDYL*DQDYL
              APPCL = DPDXL*DPDXL + DPDYL*DPDYL
              AQQCL = DQDXL*DQDXL + DQDYL*DQDYL
              HPFCL = SQRT(GPPCL)
              HQFCL = SQRT(GQQCL)
              COSAL = GPQCL/(HPFCL*HQFCL)
              SINAL = GSQRL**2/(GPPCL*GQQCL)
              COSTP = DXDPL/HPFCL
              SINTP = DYDPL/HQFCL
              COSCL = SINAL*COSTP + COSAL*SINTP
              SINCL = SINAL*SINTP - COSAL*COSTP
              IF (PRESENT(GPPC)) GPPC(I1,I2) = GPPCL
              IF (PRESENT(GQQC)) GQQC(I1,I2) = GQQCL
              IF (PRESENT(GPQC)) GPQC(I1,I2) = GPQCL
              IF (PRESENT(APPC)) APPC(I1,I2) = APPCL
              IF (PRESENT(AQQC)) AQQC(I1,I2) = AQQCL
              IF (PRESENT(APQC)) APQC(I1,I2) = APQCL
              IF (PRESENT(GSQR)) GSQR(I1,I2) = GSQRL
              IF (PRESENT(HPFC)) HPFC(I1,I2) = HPFCL
              IF (PRESENT(HQFC)) HQFC(I1,I2) = HQFCL
              IF (PRESENT(DXDP)) DXDP(I1,I2) = DXDPL
              IF (PRESENT(DYDP)) DYDP(I1,I2) = DYDPL
              IF (PRESENT(DXDQ)) DXDQ(I1,I2) = DXDQL
              IF (PRESENT(DYDQ)) DYDQ(I1,I2) = DYDQL
              IF (PRESENT(DPDX)) DPDX(I1,I2) = DPDXL
              IF (PRESENT(DPDY)) DPDY(I1,I2) = DPDYL
              IF (PRESENT(DQDX)) DQDX(I1,I2) = DQDXL
              IF (PRESENT(DQDY)) DQDY(I1,I2) = DQDYL
              IF (PRESENT(COSA)) COSA(I1,I2) = COSAL
              IF (PRESENT(COSC)) COSC(I1,I2) = COSCL
              IF (PRESENT(SINC)) SINC(I1,I2) = SINCL
              IF (PRESENT(ANGL)) ANGL(I1,I2) = ATAN2(SINCL,COSCL)*R2D
            END DO !I1
        END DO !I2
!
! -------------------------------------------------------------------- /
! 4.  Clean up
!
      DEALLOCATE ( K, C )

      END SUBROUTINE W3CGDM_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3CGDM_R8( IJG, LLG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, X, Y, &
                            NFD, SPHERE, RADIUS, DX, DY, &
                            GPPC, GQQC, GPQC, GSQR, &
                            HPFC, HQFC, APPC, AQQC, APQC, &
                            DXDP, DYDP, DXDQ, DYDQ, &
                            DPDX, DPDY, DQDX, DQDY, &
                            COSA, COSC, SINC, ANGL, RC )
!     Double precision interface
      LOGICAL, INTENT(IN)   :: IJG
      LOGICAL, INTENT(IN)   :: LLG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(8), INTENT(IN)   :: X(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: Y(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(IN),  OPTIONAL :: NFD
      LOGICAL, INTENT(IN),  OPTIONAL :: SPHERE
      REAL(8), INTENT(IN),  OPTIONAL :: RADIUS
      REAL(8), INTENT(IN),  OPTIONAL :: DX, DY
      REAL(8), INTENT(OUT), OPTIONAL :: GPPC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: GQQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: GPQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: GSQR(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: HPFC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: HQFC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: APPC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: AQQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: APQC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DXDP(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DYDP(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DXDQ(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DYDQ(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DPDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DPDY(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DQDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DQDY(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: COSA(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: COSC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: SINC(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT), OPTIONAL :: ANGL(LBO(1):UBO(1),LBO(2):UBO(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: ISTAT=0, N, I1, I2, P, Q
      LOGICAL :: SPHR
      REAL(8) :: R, FACX, FACY
      INTEGER, ALLOCATABLE :: K(:,:)
      REAL(8), ALLOCATABLE :: C(:,:)
      REAL(8) :: GPPCL, GQQCL, GPQCL
      REAL(8) :: GSQRL, HPFCL, HQFCL
      REAL(8) :: APPCL, AQQCL, APQCL
      REAL(8) :: DXDPL, DYDPL, DXDQL, DYDQL
      REAL(8) :: DPDXL, DPDYL, DQDXL, DQDYL
      REAL(8) :: COSAL, SINAL, COSTP, SINTP, COSCL, SINCL
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3CGDM_R8')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( PRESENT(NFD) ) THEN
          N = NFD
        ELSE
          N = NFD_DEFAULT
        END IF
      IF ( N.LE.0 .OR. MOD(N,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3CGDM ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      IF ( PRESENT(SPHERE) ) THEN
          SPHR = SPHERE
        ELSE
          SPHR = .TRUE.
        END IF

      IF ( PRESENT(RADIUS) ) THEN
          R = RADIUS
        ELSE
          R = REARTH
        END IF
      FACY = R*D2R
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      ALLOCATE ( K(0:N,0:N), C(0:N,0:N), STAT=ISTAT )
      IF ( ISTAT .NE. 0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3CGDM ERROR -- ', &
          'finite difference coeff allocation failed'
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
      CALL GET_FDW2( N, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute optional return quantities
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              IF ( PRESENT(DX) ) THEN
                  DXDPL = DX
                  DYDPL = ZERO
                ELSE
                  CALL DXYDP( N, K, C, IJG, LLG, ICLO, TILED, &
                              NP, NQ, LBI, UBI, P, Q, DXDPL, DYDPL, &
                              X8=X, Y8=Y, RC=ISTAT )
                  IF ( ISTAT .NE. 0 ) THEN
                      IF ( PRESENT(RC) ) THEN
                          RC = ISTAT
                          RETURN
                        ELSE
                          CALL EXTCDE (ISTAT)
                        END IF
                    END IF
                END IF
              IF ( PRESENT(DY) ) THEN
                  DXDQL = ZERO
                  DYDQL = DY
                ELSE
                  CALL DXYDQ( N, K, C, IJG, LLG, ICLO, TILED, &
                              NP, NQ, LBI, UBI, P, Q, DXDQL, DYDQL, &
                              X8=X, Y8=Y, RC=ISTAT )
                  IF ( ISTAT .NE. 0 ) THEN
                      IF ( PRESENT(RC) ) THEN
                          RC = ISTAT
                          RETURN
                        ELSE
                          CALL EXTCDE (ISTAT)
                        END IF
                    END IF
                END IF
              IF ( LLG .AND. SPHR ) THEN
                  FACX = FACY*COS(REAL(Y(I1,I2),8)*D2R)
                  DXDPL = DXDPL*FACX
                  DYDPL = DYDPL*FACY
                  DXDQL = DXDQL*FACX
                  DYDQL = DYDQL*FACY
                END IF
              GPPCL = DXDPL*DXDPL + DYDPL*DYDPL
              GQQCL = DXDQL*DXDQL + DYDQL*DYDQL
              GPQCL = DXDPL*DXDQL + DYDPL*DYDQL
              GSQRL = DXDPL*DYDQL - DXDQL*DYDPL
              IF ( GSQRL .LT. ZERO ) THEN
                  ISTAT = 1
                  WRITE(0,'(/1A,1A)') 'W3CGDM ERROR -- ', &
                  'input coordinates do not define a '// &
                  'right-handed coordinate system'
                  WRITE(0,'(1A,2A6,5A16)') 'W3CGDM ERROR --', &
                  'P','Q','GSQRL','DXDPL','DYDQL','DXDQL','DYDPL'
                  WRITE(0,'(1A,2I6,5E16.8/)') 'W3CGDM ERROR --', &
                  P,Q,GSQRL,DXDPL,DYDQL,DXDQL,DYDPL
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DPDXL = DYDQL/GSQRL
              DPDYL =-DXDQL/GSQRL
              DQDXL =-DYDPL/GSQRL
              DQDYL = DXDPL/GSQRL
              APQCL = DPDXL*DQDXL + DPDYL*DQDYL
              APPCL = DPDXL*DPDXL + DPDYL*DPDYL
              AQQCL = DQDXL*DQDXL + DQDYL*DQDYL
              HPFCL = SQRT(GPPCL)
              HQFCL = SQRT(GQQCL)
              COSAL = GPQCL/(HPFCL*HQFCL)
              SINAL = GSQRL**2/(GPPCL*GQQCL)
              COSTP = DXDPL/HPFCL
              SINTP = DYDPL/HQFCL
              COSCL = SINAL*COSTP + COSAL*SINTP
              SINCL = SINAL*SINTP - COSAL*COSTP
              IF (PRESENT(GPPC)) GPPC(I1,I2) = GPPCL
              IF (PRESENT(GQQC)) GQQC(I1,I2) = GQQCL
              IF (PRESENT(GPQC)) GPQC(I1,I2) = GPQCL
              IF (PRESENT(APPC)) APPC(I1,I2) = APPCL
              IF (PRESENT(AQQC)) AQQC(I1,I2) = AQQCL
              IF (PRESENT(APQC)) APQC(I1,I2) = APQCL
              IF (PRESENT(GSQR)) GSQR(I1,I2) = GSQRL
              IF (PRESENT(HPFC)) HPFC(I1,I2) = HPFCL
              IF (PRESENT(HQFC)) HQFC(I1,I2) = HQFCL
              IF (PRESENT(DXDP)) DXDP(I1,I2) = DXDPL
              IF (PRESENT(DYDP)) DYDP(I1,I2) = DYDPL
              IF (PRESENT(DXDQ)) DXDQ(I1,I2) = DXDQL
              IF (PRESENT(DYDQ)) DYDQ(I1,I2) = DYDQL
              IF (PRESENT(DPDX)) DPDX(I1,I2) = DPDXL
              IF (PRESENT(DPDY)) DPDY(I1,I2) = DPDYL
              IF (PRESENT(DQDX)) DQDX(I1,I2) = DQDXL
              IF (PRESENT(DQDY)) DQDY(I1,I2) = DQDYL
              IF (PRESENT(COSA)) COSA(I1,I2) = COSAL
              IF (PRESENT(COSC)) COSC(I1,I2) = COSCL
              IF (PRESENT(SINC)) SINC(I1,I2) = SINCL
              IF (PRESENT(ANGL)) ANGL(I1,I2) = ATAN2(SINCL,COSCL)*R2D
            END DO !I1
        END DO !I2
!
! -------------------------------------------------------------------- /
! 4.  Clean up
!
      DEALLOCATE ( K, C )

      END SUBROUTINE W3CGDM_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE DXYDP( N, K, C, IJG, LLG, ICLO, TILED, NP, NQ, &
                        LB, UB, P, Q, DXDP, DYDP, X4, Y4, X8, Y8, RC )
!     *** INTERNAL SUBROUTINE ***
      INTEGER, INTENT(IN)   :: N
      INTEGER, INTENT(IN)   :: K(0:N,0:N)
      REAL(8), INTENT(IN)   :: C(0:N,0:N)
      LOGICAL, INTENT(IN)   :: IJG
      LOGICAL, INTENT(IN)   :: LLG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LB(2), UB(2)
      INTEGER, INTENT(IN)   :: P, Q
      REAL(8), INTENT(OUT)  :: DXDP, DYDP
      REAL(4), INTENT(IN),  OPTIONAL :: X4(LB(1):UB(1),LB(2):UB(2))
      REAL(4), INTENT(IN),  OPTIONAL :: Y4(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: X8(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: Y8(LB(1):UB(1),LB(2):UB(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      LOGICAL, PARAMETER :: DEBUG = .FALSE.
      CHARACTER(64) :: FSTR
      LOGICAL :: TYPE_R4, TYPE_R8
      INTEGER :: P0, Q0, PP, QQ
      INTEGER :: ISTAT=0, IHEM, I, J, L, I1, I2
      REAL(8) :: XP(0:N), YP(0:N), XQ(0:N), YQ(0:N), U(0:N), V(0:N)
      REAL(8) :: X0, Y0, XC(4), YC(4), LON0, LAT0, C0
      REAL(8) :: D1DP, D2DP
!
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      TYPE_R4 = PRESENT(X4).AND.PRESENT(Y4)
      TYPE_R8 = PRESENT(X8).AND.PRESENT(Y8)
      IF ( .NOT.TYPE_R4.AND..NOT.TYPE_R8 ) THEN
          WRITE(0,'(/1A,1A/)') 'DXYDP ERROR -- ', &
          'no input grid coordinates specified'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      P0 = P
      Q0 = Q
      IF ( .NOT.TILED ) THEN
        IF ( MOD(ICLO,2).EQ.0 ) THEN
            IF ( P0.LT.1 ) THEN
                P0 = NP + P0
              ELSE IF ( P0.GT.NP ) THEN
                P0 = P0 - NP
              END IF
          END IF
        IF ( MOD(ICLO,3).EQ.0 ) THEN
            IF ( Q0.LT.1 ) THEN
                Q0 = NQ + Q0
              ELSE IF ( Q0.GT.NQ ) THEN
                Q0 = Q0 - NQ
              END IF
          END IF
        IF ( P0.LT.1 .OR. P0.GT.NP .OR. Q0.LT.1 .OR. Q0.GT.NQ ) THEN
            WRITE(0,'(/1A,1A,/1A,1A,6I6/)') 'DXYDP ERROR -- ', &
            'input index coordinates outside allowed range', &
            'DXYDP ERROR -- ','NP,NQ,P,Q,P0,Q0:',NP,NQ,P,Q,P0,Q0
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
          END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Compute DX/DP & DY/DP
!
      IF ( MOD(ICLO,2).EQ.0 ) THEN
          I = N/2
        ELSE
          IF (P0.LE.N/2) THEN
              I = P0 - 1
            ELSE IF (NP-P0.LT.N/2) THEN
              I = N + P0 - NP
            ELSE
              I = N/2
            END IF
        END IF

      IF ( MOD(ICLO,2).EQ.0 .AND. .NOT.TILED ) THEN
          QQ = Q0
          DO L = 0, N
              PP = P0 + K(L,I)
              IF ( PP.LT.1 ) THEN
                  PP = NP + PP
                ELSE IF ( PP.GT.NP ) THEN
                  PP = PP - NP
                END IF
              IF ( IJG ) THEN
                  IF ( TYPE_R4 ) THEN
                      XP(L) = X4(PP,QQ)
                      YP(L) = Y4(PP,QQ)
                    ELSE
                      XP(L) = X8(PP,QQ)
                      YP(L) = Y8(PP,QQ)
                    END IF
                ELSE
                  IF ( TYPE_R4 ) THEN
                      XP(L) = X4(QQ,PP)
                      YP(L) = Y4(QQ,PP)
                    ELSE
                      XP(L) = X8(QQ,PP)
                      YP(L) = Y8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE
          IF ( IJG ) THEN
              IF ( TYPE_R4 ) THEN
                  XP(:) = X4(P0+K(:,I),Q0)
                  YP(:) = Y4(P0+K(:,I),Q0)
                ELSE
                  XP(:) = X8(P0+K(:,I),Q0)
                  YP(:) = Y8(P0+K(:,I),Q0)
                END IF
            ELSE
              IF ( TYPE_R4 ) THEN
                  XP(:) = X4(Q0,P0+K(:,I))
                  YP(:) = Y4(Q0,P0+K(:,I))
                ELSE
                  XP(:) = X8(Q0,P0+K(:,I))
                  YP(:) = Y8(Q0,P0+K(:,I))
                END IF
            END IF
        END IF

      IF ( LLG ) THEN
          IF ( IJG ) THEN
              IF ( TYPE_R4 ) THEN
                  X0 = X4(P0,Q0); Y0 = Y4(P0,Q0);
                ELSE
                  X0 = X8(P0,Q0); Y0 = Y8(P0,Q0);
                END IF
            ELSE
              IF ( TYPE_R4 ) THEN
                  X0 = X4(Q0,P0); Y0 = Y4(Q0,P0);
                ELSE
                  X0 = X8(Q0,P0); Y0 = Y8(Q0,P0);
                END IF
            END IF
          IHEM = 1; IF (MAXVAL(YP).LT.ZERO) IHEM = -1;
          LON0 = ZERO; LAT0 = SIGN(D90,REAL(IHEM,8));
          C0 = D90 - ABS(Y0)
          CALL W3SPLX(LON0,LAT0,C0,XP,YP,U,V)
          D1DP = DOT_PRODUCT(C(:,I),U)
          D2DP = DOT_PRODUCT(C(:,I),V)
          CALL SPDDP(LON0,C0,IHEM,X0,Y0,D1DP,D2DP,DXDP,DYDP)
        ELSE !.NOT.LLG
          DXDP = DOT_PRODUCT(C(:,I),XP)
          DYDP = DOT_PRODUCT(C(:,I),YP)
        END IF !.NOT.LLG
      IF ( DEBUG ) THEN
          WRITE(FSTR,'(A,I0,A,I0,A)') &
          '(/1A,5I8,/1A,2E16.8,/1A,',N+1,'I16,3(/1A,',N+1,'E16.8))'
          WRITE(*,TRIM(FSTR)) &
          'DXYDP -- P,Q,P0,Q0,I:',P,Q,P0,Q0,I, &
          'DXYDP -- DXDP,DYDP:',DXDP,DYDP, &
          'DXYDP --  K:', K(:,I), &
          'DXYDP --  C:', C(:,I), &
          'DXYDP -- XP:',XP(:), &
          'DXYDP -- YP:',YP(:)
        END IF

      END SUBROUTINE DXYDP
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE DXYDQ( N, K, C, IJG, LLG, ICLO, TILED, NP, NQ, &
                        LB, UB, P, Q, DXDQ, DYDQ, X4, Y4, X8, Y8, RC )
!     *** INTERNAL SUBROUTINE ***
      INTEGER, INTENT(IN)   :: N
      INTEGER, INTENT(IN)   :: K(0:N,0:N)
      REAL(8), INTENT(IN)   :: C(0:N,0:N)
      LOGICAL, INTENT(IN)   :: IJG
      LOGICAL, INTENT(IN)   :: LLG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LB(2), UB(2)
      INTEGER, INTENT(IN)   :: P, Q
      REAL(8), INTENT(OUT)  :: DXDQ, DYDQ
      REAL(4), INTENT(IN),  OPTIONAL :: X4(LB(1):UB(1),LB(2):UB(2))
      REAL(4), INTENT(IN),  OPTIONAL :: Y4(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: X8(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: Y8(LB(1):UB(1),LB(2):UB(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      LOGICAL, PARAMETER :: DEBUG = .FALSE.
      CHARACTER(64) :: FSTR
      LOGICAL :: TYPE_R4, TYPE_R8
      INTEGER :: P0, Q0, PP, QQ
      INTEGER :: ISTAT=0, IHEM, I, J, L, I1, I2
      REAL(8) :: XP(0:N), YP(0:N), XQ(0:N), YQ(0:N), U(0:N), V(0:N)
      REAL(8) :: X0, Y0, XC(4), YC(4), LON0, LAT0, C0
      REAL(8) :: D1DQ, D2DQ
!
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      TYPE_R4 = PRESENT(X4).AND.PRESENT(Y4)
      TYPE_R8 = PRESENT(X8).AND.PRESENT(Y8)
      IF ( .NOT.TYPE_R4.AND..NOT.TYPE_R8 ) THEN
          WRITE(0,'(/1A,1A/)') 'DXYDQ ERROR -- ', &
          'no input grid coordinates specified'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      P0 = P
      Q0 = Q
      IF ( .NOT.TILED ) THEN
        IF ( MOD(ICLO,2).EQ.0 ) THEN
            IF ( P0.LT.1 ) THEN
                P0 = NP + P0
              ELSE IF ( P0.GT.NP ) THEN
                P0 = P0 - NP
              END IF
          END IF
        IF ( MOD(ICLO,3).EQ.0 ) THEN
            IF ( Q0.LT.1 ) THEN
                Q0 = NQ + Q0
              ELSE IF ( Q0.GT.NQ ) THEN
                Q0 = Q0 - NQ
              END IF
          END IF
        IF ( P0.LT.1 .OR. P0.GT.NP .OR. Q0.LT.1 .OR. Q0.GT.NQ ) THEN
            WRITE(0,'(/1A,1A,/1A,1A,6I6/)') 'DXYDQ ERROR -- ', &
            'input index coordinates outside allowed range', &
            'DXYDP ERROR -- ','NP,NQ,P,Q,P0,Q0:',NP,NQ,P,Q,P0,Q0
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
          END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Compute DX/DQ & DY/DQ
!
      IF ( MOD(ICLO,3).EQ.0 ) THEN
          J = N/2
        ELSE IF ( ICLO.EQ.ICLO_TRPL ) THEN
          IF (Q0.LE.N/2) THEN
              J = Q0 - 1
            ELSE
              J = N/2
            END IF
        ELSE
          IF (Q0.LE.N/2) THEN
              J = Q0 - 1
            ELSE IF (NQ-Q0.LT.N/2) THEN
              J = N + Q0 - NQ
            ELSE
              J = N/2
            END IF
        END IF

      IF ( MOD(ICLO,3).EQ.0 .AND. .NOT.TILED ) THEN
          PP = P0
          DO L = 0, N
              QQ = Q0 + K(L,J)
              IF ( QQ.LT.1 ) THEN
                  QQ = NQ + QQ
                ELSE IF ( QQ.GT.NQ ) THEN
                  QQ = QQ - NQ
                END IF
              IF ( IJG ) THEN
                  IF ( TYPE_R4 ) THEN
                      XQ(L) = X4(PP,QQ)
                      YQ(L) = Y4(PP,QQ)
                    ELSE
                      XQ(L) = X8(PP,QQ)
                      YQ(L) = Y8(PP,QQ)
                    END IF
                ELSE
                  IF ( TYPE_R4 ) THEN
                      XQ(L) = X4(QQ,PP)
                      YQ(L) = Y4(QQ,PP)
                    ELSE
                      XQ(L) = X8(QQ,PP)
                      YQ(L) = Y8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE IF ( ICLO.EQ.ICLO_TRPL .AND. .NOT.TILED ) THEN
          DO L = 0, N
              PP = P0
              QQ = Q0 + K(L,J)
              IF ( QQ.GT.NQ ) THEN
                  PP = NP - MOD(PP-1,NP)
                  QQ = NQ - MOD(QQ-1,NQ)
                END IF
              IF ( IJG ) THEN
                  IF ( TYPE_R4 ) THEN
                      XQ(L) = X4(PP,QQ)
                      YQ(L) = Y4(PP,QQ)
                    ELSE
                      XQ(L) = X8(PP,QQ)
                      YQ(L) = Y8(PP,QQ)
                    END IF
                ELSE
                  IF ( TYPE_R4 ) THEN
                      XQ(L) = X4(QQ,PP)
                      YQ(L) = Y4(QQ,PP)
                    ELSE
                      XQ(L) = X8(QQ,PP)
                      YQ(L) = Y8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE
          IF ( IJG ) THEN
              IF ( TYPE_R4 ) THEN
                  XQ(:) = X4(P0,Q0+K(:,J))
                  YQ(:) = Y4(P0,Q0+K(:,J))
                ELSE
                  XQ(:) = X8(P0,Q0+K(:,J))
                  YQ(:) = Y8(P0,Q0+K(:,J))
                END IF
            ELSE
              IF ( TYPE_R4 ) THEN
                  XQ(:) = X4(Q0+K(:,J),P0)
                  YQ(:) = Y4(Q0+K(:,J),P0)
                ELSE
                  XQ(:) = X8(Q0+K(:,J),P0)
                  YQ(:) = Y8(Q0+K(:,J),P0)
                END IF
            END IF
        END IF

      IF ( LLG ) THEN
          IF ( IJG ) THEN
              IF ( TYPE_R4 ) THEN
                  X0 = X4(P0,Q0); Y0 = Y4(P0,Q0);
                ELSE
                  X0 = X8(P0,Q0); Y0 = Y8(P0,Q0);
                END IF
            ELSE
              IF ( TYPE_R4 ) THEN
                  X0 = X4(Q0,P0); Y0 = Y4(Q0,P0);
                ELSE
                  X0 = X8(Q0,P0); Y0 = Y8(Q0,P0);
                END IF
            END IF
          IHEM = 1; IF (MAXVAL(YQ).LT.ZERO) IHEM = -1;
          LON0 = ZERO; LAT0 = SIGN(D90,REAL(IHEM,8));
          C0 = D90 - ABS(Y0)
          CALL W3SPLX(LON0,LAT0,C0,XQ,YQ,U,V)
          D1DQ = DOT_PRODUCT(C(:,J),U)
          D2DQ = DOT_PRODUCT(C(:,J),V)
          CALL SPDDQ(LON0,C0,IHEM,X0,Y0,D1DQ,D2DQ,DXDQ,DYDQ)
        ELSE !.NOT.LLG
          DXDQ = DOT_PRODUCT(C(:,J),XQ)
          DYDQ = DOT_PRODUCT(C(:,J),YQ)
        END IF !.NOT.LLG
      IF ( DEBUG ) THEN
          WRITE(FSTR,'(A,I0,A,I0,A)') &
          '(/1A,5I8,/1A,2E16.8,/1A,',N+1,'I16,3(/1A,',N+1,'E16.8))'
          WRITE(*,TRIM(FSTR)) &
          'DXYDQ -- P,Q,P0,Q0,J:',P,Q,P0,Q0,J, &
          'DXYDQ -- DXDQ,DYDQ:',DXDQ,DYDQ, &
          'DXYDQ --  K:', K(:,J), &
          'DXYDQ --  C:', C(:,J), &
          'DXYDQ -- XQ:',XQ(:), &
          'DXYDQ -- YQ:',YQ(:)
        END IF

      END SUBROUTINE DXYDQ
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE GET_FDW2( N, M, K, C )
!     *** INTERNAL SUBROUTINE ***
      INTEGER,INTENT(IN) :: N, M
      INTEGER,INTENT(OUT):: K(0:N,0:N)
      REAL(8),INTENT(OUT):: C(0:N,0:N)
      INTEGER :: I, J
      REAL(8) :: A(0:N), B(0:N,0:M)

      DO I = 0, N
          DO J = 0, N
              K(J,I) = J-I
              A(J) = K(J,I)
            END DO
          CALL W3FDWT( N, N, M, ZERO, A, B )
          C(0:N,I) = B(0:N,M)
         !WRITE(0,'(A,I1,2X,11I16)') 'I=',I,K(0:N,I)
         !WRITE(0,'(5X,11E16.8)') C(0:N,I)
        END DO

      END SUBROUTINE GET_FDW2
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE SPDDP( LAM0, C0, IHEM, LAM, PHI, DXDP, DYDP, &
                        DLAMDP, DPHIDP )
!     *** INTERNAL SUBROUTINE ***
!     Routine to compute polar stereographic transformation of
!     grid derivatives dx/dp & dy/dp to dlam/dp & dphi/dp.
!
!     mu = lam - lam0
!     nu = pi/4 - alpha*phi/2
!     k0 = cos(c0/2)**2
!
!     dlam/dx = (     1/(2*R*k0)) * cot(nu)   * cos(mu)
!     dlam/dy = ( alpha/(2*R*k0)) * cot(mu)   * sin(mu)
!     dphi/dx = (-alpha/(  R*k0)) * cos(mu)^2 * sin(mu)
!     dphi/dy = (     1/(  R*k0)) * cos(mu)^2 * cos(mu)
!
!     dlam/dp = dx/dp*dlam/dx + dy/dp*dlam/dy
!     dphi/dp = dx/dp*dphi/dx + dy/dp*dphi/dy
!     dlam/dq = dx/dq*dlam/dx + dy/dq*dlam/dy
!     dphi/dq = dx/dq*dphi/dx + dy/dq*dphi/dy
!
      REAL(8),INTENT(IN) :: LAM0, C0
      INTEGER,INTENT(IN) :: IHEM
      REAL(8),INTENT(IN) :: LAM, PHI
      REAL(8),INTENT(IN) :: DXDP, DYDP
      REAL(8),INTENT(OUT):: DLAMDP, DPHIDP

!     Local parameters
      REAL(8) :: K0, A, MU, NU, FAC
      REAL(8) :: CMU, SMU, CNU2, TNUI
      REAL(8) :: DLAMDX, DLAMDY, DPHIDX, DPHIDY

      K0  = COS(HALF*C0*D2R)**2
      MU  = (LAM-LAM0)*D2R
      A   = SIGN(ONE,REAL(IHEM,8))
      NU  = PIO4 - A*HALF*PHI*D2R
      FAC = R2D*HALF/REARTH/K0

      CMU  = COS(MU)
      SMU  = SIN(MU)
      CNU2 = COS(NU)**2
      TNUI = ONE/TAN(NU)

      DLAMDX =        FAC*CMU*TNUI
      DLAMDY =      A*FAC*SMU*TNUI
      DPHIDX = -A*TWO*FAC*SMU*CNU2
      DPHIDY =    TWO*FAC*CMU*CNU2

      DLAMDP = DXDP*DLAMDX + DYDP*DLAMDY
      DPHIDP = DXDP*DPHIDX + DYDP*DPHIDY

      END SUBROUTINE SPDDP
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE SPDDQ( LAM0, C0, IHEM, LAM, PHI, DXDQ, DYDQ, &
                        DLAMDQ, DPHIDQ )
!     *** INTERNAL SUBROUTINE ***
!     Routine to compute polar stereographic transformation of
!     grid derivatives dx/dq & dy/dq to dlam/dq & dphi/dq.
!
!     mu = lam - lam0
!     nu = pi/4 - alpha*phi/2
!     k0 = cos(c0/2)**2
!
!     dlam/dx = (     1/(2*R*k0)) * cot(nu)   * cos(mu)
!     dlam/dy = ( alpha/(2*R*k0)) * cot(mu)   * sin(mu)
!     dphi/dx = (-alpha/(  R*k0)) * cos(mu)^2 * sin(mu)
!     dphi/dy = (     1/(  R*k0)) * cos(mu)^2 * cos(mu)
!
!     dlam/dp = dx/dp*dlam/dx + dy/dp*dlam/dy
!     dphi/dp = dx/dp*dphi/dx + dy/dp*dphi/dy
!     dlam/dq = dx/dq*dlam/dx + dy/dq*dlam/dy
!     dphi/dq = dx/dq*dphi/dx + dy/dq*dphi/dy
!
      REAL(8),INTENT(IN) :: LAM0, C0
      INTEGER,INTENT(IN) :: IHEM
      REAL(8),INTENT(IN) :: LAM, PHI
      REAL(8),INTENT(IN) :: DXDQ, DYDQ
      REAL(8),INTENT(OUT):: DLAMDQ, DPHIDQ

!     Local parameters
      REAL(8) :: K0, A, MU, NU, FAC
      REAL(8) :: CMU, SMU, CNU2, TNUI
      REAL(8) :: DLAMDX, DLAMDY, DPHIDX, DPHIDY

      K0  = COS(HALF*C0*D2R)**2
      MU  = (LAM-LAM0)*D2R
      A   = SIGN(ONE,REAL(IHEM,8))
      NU  = PIO4 - A*HALF*PHI*D2R
      FAC = R2D*HALF/REARTH/K0

      CMU  = COS(MU)
      SMU  = SIN(MU)
      CNU2 = COS(NU)**2
      TNUI = ONE/TAN(NU)

      DLAMDX =        FAC*CMU*TNUI
      DLAMDY =      A*FAC*SMU*TNUI
      DPHIDX = -A*TWO*FAC*SMU*CNU2
      DPHIDY =    TWO*FAC*CMU*CNU2

      DLAMDQ = DXDQ*DLAMDX + DYDQ*DLAMDY
      DPHIDQ = DXDQ*DPHIDX + DYDQ*DPHIDY

      END SUBROUTINE SPDDQ
!/
!/ End of W3CGDM ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3GRD0( NFD, IJG, ICLO, TILED, &
!/                       NP, NQ, LBI, UBI, LBO, UBO, &
!/                       DPDX, DPDY, DQDX, DQDY, &
!/                       F, DFDX, DFDY, MASK, RC )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute curvilinear gradient of a scalar field.
!
!  2. Method :
!
!     Compute derivatives using finite-difference method.
!     Apply curvilinear grid metric.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NFD     Int.   I   Finite-difference order (even)
!       IJG     Log.   I   Logical flag indicating ordering of input
!                          coord. arrays: T = (NP,NQ) and F = (NP,NQ)
!       LLG     Log.   I   Spherical coordinate (lon,lat) flag
!       ICLO    Int.   I   Parameter indicating type of index space closure.
!       TILED   Log.   I   Logical flag indicating that input arrays are tiled
!                          with halos of width >= NFD/2
!       NP      Int.   I   Range of P index coordinate: P in [1,NP]
!       NQ      Int.   I   Range of Q index coordinate: Q in [1,NQ]
!       LBI     I.A.   I   Lower-bound of  input arrays, DIMENSION(2)
!       UBI     I.A.   I   Upper-bound of  input arrays, DIMENSION(2)
!       LBO     I.A.   I   Lower-bound of output arrays, DIMENSION(2)
!       UBO     I.A.   I   Upper-bound of output arrays, DIMENSION(2)
!       DPDX    R.A.   I   dp/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DPDY    R.A.   I   dp/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDX    R.A.   I   dq/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDY    R.A.   I   dq/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       F       R.A.   I   Scalar input field, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DFDX    R.A.   O   df/dx, DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DFDY    R.A.   O   df/dy, DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       MASK    L.A.   I   OPTIONAL logical mask (T = invalid, F = valid)
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       RC      Int.   O   OPTIONAL return code (!= 0 if error occurs)
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - If RC is not provided and an error occurs, then the routine will
!       report error to stderr and attempt to abort the calling program.
!     - When MASK is specified, points that are masked are excluded from
!       the finite-difference stencil.  In order to avoid reaching across
!       masked regions, the stencil is modified to one-sided and/or the
!       finite-difference order is reduced.  If the masking results in a
!       single point wide channel, then the derivative in the direction
!       across the channel is set to zero.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3GRD0_R4( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            F, DFDX, DFDY, MASK, RC )
!     Single precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(4), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::    F(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(OUT)  :: DFDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT)  :: DFDY(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DFDP, DFDQ
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GRD0_R4')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3GRD0 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute dF/dx & dF/dy
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F4=F, DFDP=DFDP, DFDQ=DFDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DFDX(I1,I2) = DFDP*DPDX(I1,I2) + DFDQ*DQDX(I1,I2)
              DFDY(I1,I2) = DFDP*DPDY(I1,I2) + DFDQ*DQDY(I1,I2)
            END DO !I1
        END DO !I2

      END SUBROUTINE W3GRD0_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3GRD0_R8( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            F, DFDX, DFDY, MASK, RC )
!     Double precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(8), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::    F(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(OUT)  :: DFDX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT)  :: DFDY(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DFDP, DFDQ
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3GRD0_R8')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3GRD0 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute dF/dx & dF/dy
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F8=F, DFDP=DFDP, DFDQ=DFDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DFDX(I1,I2) = DFDP*DPDX(I1,I2) + DFDQ*DQDX(I1,I2)
              DFDY(I1,I2) = DFDP*DPDY(I1,I2) + DFDQ*DQDY(I1,I2)
            END DO !I1
        END DO !I2

      END SUBROUTINE W3GRD0_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE DFDPQ( N, K, C, IJG, ICLO, TILED, &
                        NP, NQ, LB, UB, P, Q, &
                        F4, F8, DFDP, DFDQ, &
                        G4, G8, DGDP, DGDQ, &
                        H4, H8, DHDP, DHDQ, &
                        MASK, RC )
!     *** INTERNAL SUBROUTINE ***
      INTEGER, INTENT(IN)   :: N
      INTEGER, INTENT(IN)   :: K(0:N,0:N,1:N)
      REAL(8), INTENT(IN)   :: C(0:N,0:N,1:N)
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LB(2), UB(2)
      INTEGER, INTENT(IN)   :: P, Q
      REAL(4), INTENT(IN),  OPTIONAL :: F4(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: F8(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DFDP, DFDQ
      REAL(4), INTENT(IN),  OPTIONAL :: G4(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: G8(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DGDP, DGDQ
      REAL(4), INTENT(IN),  OPTIONAL :: H4(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(IN),  OPTIONAL :: H8(LB(1):UB(1),LB(2):UB(2))
      REAL(8), INTENT(OUT), OPTIONAL :: DHDP, DHDQ
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LB(1):UB(1),LB(2):UB(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      LOGICAL, PARAMETER :: DEBUG = .FALSE.
      CHARACTER(64) :: FSTR
      LOGICAL :: COMP_M, COMP_F, COMP_G, COMP_H, TYPE_R4
      INTEGER :: P0, Q0, PP, QQ
      INTEGER :: ISTAT=0, I, J, L, II, JJ, NI, NJ
      LOGICAL :: MP(0:N), MQ(0:N)
      REAL(8) :: FP(0:N), FQ(0:N)
      REAL(8) :: GP(0:N), GQ(0:N)
      REAL(8) :: HP(0:N), HQ(0:N)
!
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      COMP_F = ( PRESENT(F4) .OR. PRESENT(F8) ) .AND. &
               PRESENT(DFDP) .AND. PRESENT(DFDQ)
      COMP_G = ( PRESENT(G4) .OR. PRESENT(G8) ) .AND. &
               PRESENT(DGDP) .AND. PRESENT(DGDQ)
      COMP_H = ( PRESENT(H4) .OR. PRESENT(H8) ) .AND. &
               PRESENT(DHDP) .AND. PRESENT(DHDQ)
      IF ( .NOT.COMP_F.AND..NOT.COMP_G.AND..NOT.COMP_H ) RETURN

      IF ( COMP_F ) THEN
          TYPE_R4 = PRESENT(F4)
        ELSE IF ( COMP_G ) THEN
          TYPE_R4 = PRESENT(G4)
        ELSE IF ( COMP_H ) THEN
          TYPE_R4 = PRESENT(H4)
        END IF

      P0 = P
      Q0 = Q
      IF ( .NOT.TILED ) THEN
        IF ( MOD(ICLO,2).EQ.0 ) THEN
            IF ( P0.LT.1 ) THEN
                P0 = NP + P0
              ELSE IF ( P0.GT.NP ) THEN
                P0 = P0 - NP
              END IF
          END IF
        IF ( MOD(ICLO,3).EQ.0 ) THEN
            IF ( Q0.LT.1 ) THEN
                Q0 = NQ + Q0
              ELSE IF ( Q0.GT.NQ ) THEN
                Q0 = Q0 - NQ
              END IF
          END IF
        IF ( P0.LT.1 .OR. P0.GT.NP .OR. Q0.LT.1 .OR. Q0.GT.NQ ) THEN
            WRITE(0,'(/1A,1A,/1A,1A,6I6/)') 'DFDPQ ERROR -- ', &
            'input index coordinates outside allowed range', &
            'DXYDP ERROR -- ','NP,NQ,P,Q,P0,Q0:',NP,NQ,P,Q,P0,Q0
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
          END IF
        END IF

      COMP_M = PRESENT(MASK)
      IF ( COMP_M ) THEN
          IF ( IJG ) THEN
               IF ( MASK(P0,Q0) ) RETURN
            ELSE
               IF ( MASK(Q0,P0) ) RETURN
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Compute DF/DP
!
      IF ( MOD(ICLO,2).EQ.0 ) THEN
          I = N/2
        ELSE
          IF (P0.LE.N/2) THEN
              I = P0 - 1
            ELSE IF (NP-P0.LT.N/2) THEN
              I = N + P0 - NP
            ELSE
              I = N/2
            END IF
        END IF

      IF ( MOD(ICLO,2).EQ.0 .AND. .NOT.TILED ) THEN
          QQ = Q0
          DO L = 0, N
              PP = P0 + K(L,I,N)
              IF ( PP.LT.1 ) THEN
                  PP = NP + PP
                ELSE IF ( PP.GT.NP ) THEN
                  PP = PP - NP
                END IF
              IF ( IJG ) THEN
                  IF ( COMP_M ) MP(L) = MASK(PP,QQ)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FP(L) = F4(PP,QQ)
                      IF ( COMP_G ) GP(L) = G4(PP,QQ)
                      IF ( COMP_H ) HP(L) = H4(PP,QQ)
                    ELSE
                      IF ( COMP_F ) FP(L) = F8(PP,QQ)
                      IF ( COMP_G ) GP(L) = G8(PP,QQ)
                      IF ( COMP_H ) HP(L) = H8(PP,QQ)
                    END IF
                ELSE
                  IF ( COMP_M ) MP(L) = MASK(QQ,PP)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FP(L) = F4(QQ,PP)
                      IF ( COMP_G ) GP(L) = G4(QQ,PP)
                      IF ( COMP_H ) HP(L) = H4(QQ,PP)
                    ELSE
                      IF ( COMP_F ) FP(L) = F8(QQ,PP)
                      IF ( COMP_G ) GP(L) = G8(QQ,PP)
                      IF ( COMP_H ) HP(L) = H8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE
          IF ( IJG ) THEN
              IF ( COMP_M ) MP(:) = MASK(P0+K(:,I,N),Q0)
              IF ( TYPE_R4 ) THEN
                  IF ( COMP_F ) FP(:) = F4(P0+K(:,I,N),Q0)
                  IF ( COMP_G ) GP(:) = G4(P0+K(:,I,N),Q0)
                  IF ( COMP_H ) HP(:) = H4(P0+K(:,I,N),Q0)
                ELSE
                  IF ( COMP_F ) FP(:) = F8(P0+K(:,I,N),Q0)
                  IF ( COMP_G ) GP(:) = G8(P0+K(:,I,N),Q0)
                  IF ( COMP_H ) HP(:) = H8(P0+K(:,I,N),Q0)
                END IF
            ELSE
              IF ( COMP_M ) MP(:) = MASK(Q0,P0+K(:,I,N))
              IF ( TYPE_R4 ) THEN
                  IF ( COMP_F ) FP(:) = F4(Q0,P0+K(:,I,N))
                  IF ( COMP_G ) GP(:) = G4(Q0,P0+K(:,I,N))
                  IF ( COMP_H ) HP(:) = H4(Q0,P0+K(:,I,N))
                ELSE
                  IF ( COMP_F ) FP(:) = F8(Q0,P0+K(:,I,N))
                  IF ( COMP_G ) GP(:) = G8(Q0,P0+K(:,I,N))
                  IF ( COMP_H ) HP(:) = H8(Q0,P0+K(:,I,N))
                END IF
            END IF
        END IF

      II = I
      NI = N
      IF ( COMP_M ) THEN
          DO L = N, I+1, -1
              IF ( MP(L) ) NI = NI - 1
            END DO
          DO L = 0, I-1
              IF ( MP(L) ) THEN
                  NI = NI - 1
                  II = II - 1
                END IF
            END DO
        END IF
!     IF ( NI.LE.0 ) THEN
!         WRITE(0,'(/1A,1A,4I6/)') 'DFDPQ ERROR -- ', &
!         'DFDP -- single point wide channel not allowed',P,Q,P0,Q0
!         ISTAT = 1
!         IF ( PRESENT(RC) ) THEN
!             RC = ISTAT
!             RETURN
!           ELSE
!             CALL EXTCDE (ISTAT)
!           END IF
!       END IF

      IF ( NI.GT.0 ) THEN
          IF ( COMP_F ) DFDP = DOT_PRODUCT(C(0:NI,II,NI),FP(I-II:NI))
          IF ( COMP_G ) DGDP = DOT_PRODUCT(C(0:NI,II,NI),GP(I-II:NI))
          IF ( COMP_H ) DHDP = DOT_PRODUCT(C(0:NI,II,NI),HP(I-II:NI))
          IF ( DEBUG ) THEN
              WRITE(FSTR,'(A,I0,A,I0,A)') '(/1A,6I6,/1A,',&
              NI+1,'I16,/1A,',NI+1,'E16.8)'
              WRITE(*,TRIM(FSTR)) &
              'DFDPQ -- DFDP -- P,Q,P0,Q0,NI,II:',P,Q,P0,Q0,NI,II, &
              'DFDPQ -- DFDP --  K:', K(0:NI,II,NI), &
              'DFDPQ -- DFDP --  C:', C(0:NI,II,NI)
            END IF
        ELSE
          WRITE(0,'(/1A,1A,4I6/)') 'DFDPQ WARNING -- ', &
          'single point wide channel, DFDP set to zero:',P,Q,P0,Q0
          IF ( COMP_F ) DFDP = ZERO
          IF ( COMP_G ) DGDP = ZERO
          IF ( COMP_H ) DHDP = ZERO
        END IF
!
! -------------------------------------------------------------------- /
! 3.  Compute DF/DQ
!
      IF ( MOD(ICLO,3).EQ.0 ) THEN
          J = N/2
        ELSE IF ( ICLO.EQ.ICLO_TRPL ) THEN
          IF (Q0.LE.N/2) THEN
              J = Q0 - 1
            ELSE
              J = N/2
            END IF
        ELSE
          IF (Q0.LE.N/2) THEN
              J = Q0 - 1
            ELSE IF (NQ-Q0.LT.N/2) THEN
              J = N + Q0 - NQ
            ELSE
              J = N/2
            END IF
        END IF

      IF ( MOD(ICLO,3).EQ.0 .AND. .NOT.TILED ) THEN
          PP = P0
          DO L = 0, N
              QQ = Q0 + K(L,J,N)
              IF ( QQ.LT.1 ) THEN
                  QQ = NQ + QQ
                ELSE IF ( QQ.GT.NQ ) THEN
                  QQ = QQ - NQ
                END IF
              IF ( IJG ) THEN
                  IF ( COMP_M ) MQ(L) = MASK(PP,QQ)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FQ(L) = F4(PP,QQ)
                      IF ( COMP_G ) GQ(L) = G4(PP,QQ)
                      IF ( COMP_H ) HQ(L) = H4(PP,QQ)
                    ELSE
                      IF ( COMP_F ) FQ(L) = F8(PP,QQ)
                      IF ( COMP_G ) GQ(L) = G8(PP,QQ)
                      IF ( COMP_H ) HQ(L) = H8(PP,QQ)
                    END IF
                ELSE
                  IF ( COMP_M ) MQ(L) = MASK(QQ,PP)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FQ(L) = F4(QQ,PP)
                      IF ( COMP_G ) GQ(L) = G4(QQ,PP)
                      IF ( COMP_H ) HQ(L) = H4(QQ,PP)
                    ELSE
                      IF ( COMP_F ) FQ(L) = F8(QQ,PP)
                      IF ( COMP_G ) GQ(L) = G8(QQ,PP)
                      IF ( COMP_H ) HQ(L) = H8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE IF ( ICLO.EQ.ICLO_TRPL .AND. .NOT.TILED ) THEN
          DO L = 0, N
              PP = P0
              QQ = Q0 + K(L,J,N)
              IF ( QQ.GT.NQ ) THEN
                  PP = NP - MOD(PP-1,NP)
                  QQ = NQ - MOD(QQ-1,NQ)
                END IF
              IF ( IJG ) THEN
                  IF ( COMP_M ) MQ(L) = MASK(PP,QQ)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FQ(L) = F4(PP,QQ)
                      IF ( COMP_G ) GQ(L) = G4(PP,QQ)
                      IF ( COMP_H ) HQ(L) = H4(PP,QQ)
                    ELSE
                      IF ( COMP_F ) FQ(L) = F8(PP,QQ)
                      IF ( COMP_G ) GQ(L) = G8(PP,QQ)
                      IF ( COMP_H ) HQ(L) = H8(PP,QQ)
                    END IF
                ELSE
                  IF ( COMP_M ) MQ(L) = MASK(QQ,PP)
                  IF ( TYPE_R4 ) THEN
                      IF ( COMP_F ) FQ(L) = F4(QQ,PP)
                      IF ( COMP_G ) GQ(L) = G4(QQ,PP)
                      IF ( COMP_H ) HQ(L) = H4(QQ,PP)
                    ELSE
                      IF ( COMP_F ) FQ(L) = F8(QQ,PP)
                      IF ( COMP_G ) GQ(L) = G8(QQ,PP)
                      IF ( COMP_H ) HQ(L) = H8(QQ,PP)
                    END IF
                END IF
            END DO
        ELSE
          IF ( IJG ) THEN
              IF ( COMP_M ) MQ(:) = MASK(P0,Q0+K(:,J,N))
              IF ( TYPE_R4 ) THEN
                  IF ( COMP_F ) FQ(:) = F4(P0,Q0+K(:,J,N))
                  IF ( COMP_G ) GQ(:) = G4(P0,Q0+K(:,J,N))
                  IF ( COMP_H ) HQ(:) = H4(P0,Q0+K(:,J,N))
                ELSE
                  IF ( COMP_F ) FQ(:) = F8(P0,Q0+K(:,J,N))
                  IF ( COMP_G ) GQ(:) = G8(P0,Q0+K(:,J,N))
                  IF ( COMP_H ) HQ(:) = H8(P0,Q0+K(:,J,N))
                END IF
            ELSE
              IF ( COMP_M ) MQ(:) = MASK(Q+K(:,J,N),P)
              IF ( TYPE_R4 ) THEN
                  IF ( COMP_F ) FQ(:) = F4(Q0+K(:,J,N),P0)
                  IF ( COMP_G ) GQ(:) = G4(Q0+K(:,J,N),P0)
                  IF ( COMP_H ) HQ(:) = H4(Q0+K(:,J,N),P0)
                ELSE
                  IF ( COMP_F ) FQ(:) = F8(Q0+K(:,J,N),P0)
                  IF ( COMP_G ) GQ(:) = G8(Q0+K(:,J,N),P0)
                  IF ( COMP_H ) HQ(:) = H8(Q0+K(:,J,N),P0)
                END IF
            END IF
        END IF

      JJ = J
      NJ = N
      IF ( COMP_M ) THEN
          DO L = N, J+1, -1
              IF ( MQ(L) ) NJ = NJ - 1
            END DO
          DO L = 0, J-1
              IF ( MQ(L) ) THEN
                  NJ = NJ - 1
                  JJ = JJ - 1
                END IF
            END DO
        END IF
!     IF ( NJ.LE.0 ) THEN
!         WRITE(0,'(/1A,1A,4I6/)') 'DFDPQ ERROR -- ', &
!         'DFDQ -- single point wide channel not allowed',P,Q,P0,Q0
!         ISTAT = 1
!         IF ( PRESENT(RC) ) THEN
!             RC = ISTAT
!             RETURN
!           ELSE
!             CALL EXTCDE (ISTAT)
!           END IF
!       END IF

      IF ( NJ.GT.0 ) THEN
          IF ( COMP_F ) DFDQ = DOT_PRODUCT(C(0:NJ,JJ,NJ),FQ(J-JJ:NJ))
          IF ( COMP_G ) DGDQ = DOT_PRODUCT(C(0:NJ,JJ,NJ),GQ(J-JJ:NJ))
          IF ( COMP_H ) DHDQ = DOT_PRODUCT(C(0:NJ,JJ,NJ),HQ(J-JJ:NJ))
          IF ( DEBUG ) THEN
              WRITE(FSTR,'(A,I0,A,I0,A)') '(/1A,6I6,/1A,',&
              NJ+1,'I16,/1A,',NJ+1,'E16.8)'
              WRITE(*,TRIM(FSTR)) &
              'DFDPQ -- DFDQ -- P,Q,P0,Q0,NJ,JJ:',P,Q,P0,Q0,NJ,JJ, &
              'DFDPQ -- DFDQ --  K:', K(0:NJ,JJ,NJ), &
              'DFDPQ -- DFDQ --  C:', C(0:NJ,JJ,NJ)
            END IF
        ELSE
          WRITE(0,'(/1A,1A,4I6/)') 'DFDPQ WARNING -- ', &
          'single point wide channel, DFDQ set to zero:',P,Q,P0,Q0
          IF ( COMP_F ) DFDQ = ZERO
          IF ( COMP_G ) DGDQ = ZERO
          IF ( COMP_H ) DHDQ = ZERO
        END IF

      END SUBROUTINE DFDPQ
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE GET_FDW3( N, M, K, C )
!     *** INTERNAL SUBROUTINE ***
      INTEGER,INTENT(IN) :: N, M
      INTEGER,INTENT(OUT):: K(0:N,0:N,1:N)
      REAL(8),INTENT(OUT):: C(0:N,0:N,1:N)
      INTEGER :: L, I, J
      REAL(8) :: A(0:N), B(0:N,0:M)

      DO L = 1, N
         !WRITE(0,'(A,I1,2X,11A)') 'L=',L,('----------------',I=0,L)
          DO I = 0, L
              DO J = 0, L
                  K(J,I,L) = J-I
                  A(J) = K(J,I,L)
                END DO
              CALL W3FDWT( L, N, M, ZERO, A, B )
              C(0:L,I,L) = B(0:L,M)
             !WRITE(0,'(A,I1,2X,11I16)') 'I=',I,K(0:L,I,L)
             !WRITE(0,'(5X,11E16.8)') C(0:L,I,L)
            END DO
        END DO

      END SUBROUTINE GET_FDW3
!/
!/ End of W3GRD0 ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3DIV1( NFD, IJG, ICLO, TILED, &
!/                       NP, NQ, LBI, UBI, LBO, UBO, &
!/                       DPDX, DPDY, DQDX, DQDY, &
!/                       VP, VQ, DIVV, MASK, RC )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute curvilinear divergence of a vector field.
!
!  2. Method :
!
!     Compute derivatives using finite-difference method.
!     Apply curvilinear grid metric.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NFD     Int.   I   Finite-difference order (even)
!       IJG     Log.   I   Logical flag indicating ordering of input
!                          coord. arrays: T = (NP,NQ) and F = (NP,NQ)
!       LLG     Log.   I   Spherical coordinate (lon,lat) flag
!       ICLO    Int.   I   Parameter indicating type of index space closure.
!       TILED   Log.   I   Logical flag indicating that input arrays are tiled
!                          with halos of width >= NFD/2
!       NP      Int.   I   Range of P index coordinate: P in [1,NP]
!       NQ      Int.   I   Range of Q index coordinate: Q in [1,NQ]
!       LBI     I.A.   I   Lower-bound of  input arrays, DIMENSION(2)
!       UBI     I.A.   I   Upper-bound of  input arrays, DIMENSION(2)
!       LBO     I.A.   I   Lower-bound of output arrays, DIMENSION(2)
!       UBO     I.A.   I   Upper-bound of output arrays, DIMENSION(2)
!       DPDX    R.A.   I   dp/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DPDY    R.A.   I   dp/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDX    R.A.   I   dq/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDY    R.A.   I   dq/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       VP      R.A.   I   p-component of input vector field,
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       VQ      R.A.   I   q-component of input vector field,
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DIVV    R.A.   O   div(V), DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       MASK    L.A.   I   OPTIONAL logical mask (T = invalid, F = valid)
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       RC      Int.   O   OPTIONAL return code (!= 0 if error occurs)
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - If RC is not provided and an error occurs, then the routine will
!       report error to stderr and attempt to abort the calling program.
!     - When MASK is specified, points that are masked are excluded from
!       the finite-difference stencil.  In order to avoid reaching across
!       masked regions, the stencil is modified to one-sided and/or the
!       finite-difference order is reduced.  If the masking results in a
!       single point wide channel, then the derivative in the direction
!       across the channel is set to zero.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3DIV1_R4( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            VP, VQ, DIVV, MASK, RC )
!     Single precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(4), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::   VP(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::   VQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(OUT)  :: DIVV(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DVPDP, DVPDQ, DVQDP, DVQDQ
      REAL(8) :: DVXDX, DVYDY
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIV1_R4')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV1 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3DIV1 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV1 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute div(V) = dV_x/dx + dV_y/dy
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F4=VP, DFDP=DVPDP, DFDQ=DVPDQ, &
                           G4=VQ, DGDP=DVQDP, DGDQ=DVQDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DVXDX = DVPDP*DPDX(I1,I2) + DVPDQ*DQDX(I1,I2)
              DVYDY = DVQDP*DPDY(I1,I2) + DVQDQ*DQDY(I1,I2)
              DIVV(I1,I2) = DVXDX + DVYDY
            END DO !I1
        END DO !I2

      END SUBROUTINE W3DIV1_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3DIV1_R8( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            VP, VQ, DIVV, MASK, RC )
!     Double precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(8), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::   VP(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::   VQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(OUT)  :: DIVV(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DVPDP, DVPDQ, DVQDP, DVQDQ
      REAL(8) :: DVXDX, DVYDY
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIV1_R4')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3GRD0 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3GRD0 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute div(V) = dV_x/dx + dV_y/dy
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F8=VP, DFDP=DVPDP, DFDQ=DVPDQ, &
                           G8=VQ, DGDP=DVQDP, DGDQ=DVQDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DVXDX = DVPDP*DPDX(I1,I2) + DVPDQ*DQDX(I1,I2)
              DVYDY = DVQDP*DPDY(I1,I2) + DVQDQ*DQDY(I1,I2)
              DIVV(I1,I2) = DVXDX + DVYDY
            END DO !I1
        END DO !I2

      END SUBROUTINE W3DIV1_R8
!/
!/ End of W3DIV1 ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3DIV2( NFD, IJG, ICLO, TILED, &
!/                       NP, NQ, LBI, UBI, LBO, UBO, &
!/                       DPDX, DPDY, DQDX, DQDY, &
!/                       SPP, SQQ, SPQ, DSX, DSY, MASK, RC )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute curvilinear divergence of a rank 2 symmetric tensor field.
!
!  2. Method :
!
!     Compute derivatives using finite-difference method.
!     Apply curvilinear grid metric.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NFD     Int.   I   Finite-difference order (even)
!       IJG     Log.   I   Logical flag indicating ordering of input
!                          coord. arrays: T = (NP,NQ) and F = (NP,NQ)
!       LLG     Log.   I   Spherical coordinate (lon,lat) flag
!       ICLO    Int.   I   Parameter indicating type of index space closure.
!       TILED   Log.   I   Logical flag indicating that input arrays are tiled
!                          with halos of width >= NFD/2
!       NP      Int.   I   Range of P index coordinate: P in [1,NP]
!       NQ      Int.   I   Range of Q index coordinate: Q in [1,NQ]
!       LBI     I.A.   I   Lower-bound of  input arrays, DIMENSION(2)
!       UBI     I.A.   I   Upper-bound of  input arrays, DIMENSION(2)
!       LBO     I.A.   I   Lower-bound of output arrays, DIMENSION(2)
!       UBO     I.A.   I   Upper-bound of output arrays, DIMENSION(2)
!       DPDX    R.A.   I   dp/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DPDY    R.A.   I   dp/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDX    R.A.   I   dq/dx, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DQDY    R.A.   I   dq/dy, DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       SPP     R.A.   I   pp-component of input tensor field,
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       SQQ     R.A.   I   qq-component of input vector field,
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       SPQ     R.A.   I   pq-component of input vector field,
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       DSX     R.A.   O   div(S)_x, DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       DSY     R.A.   O   div(S)_y, DIMENSION(LBO(1):UBO(1),LBO(2):UBO(2))
!       MASK    L.A.   I   OPTIONAL logical mask (T = invalid, F = valid)
!                          DIMENSION(LBI(1):UBI(1),LBI(2):UBI(2))
!       RC      Int.   O   OPTIONAL return code (!= 0 if error occurs)
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - If RC is not provided and an error occurs, then the routine will
!       report error to stderr and attempt to abort the calling program.
!     - When MASK is specified, points that are masked are excluded from
!       the finite-difference stencil.  In order to avoid reaching across
!       masked regions, the stencil is modified to one-sided and/or the
!       finite-difference order is reduced.  If the masking results in a
!       single point wide channel, then the derivative in the direction
!       across the channel is set to zero.
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3DIV2_R4( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            SPP, SQQ, SPQ, DSX, DSY, MASK, RC )
!     Single precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(4), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::  SPP(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::  SQQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(IN)   ::  SPQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(4), INTENT(OUT)  ::  DSX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(4), INTENT(OUT)  ::  DSY(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DPPDP, DPPDQ, DQQDP, DQQDQ, DPQDP, DPQDQ
      REAL(8) :: DXXDX, DYYDY, DXYDX, DXYDY
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIV2_R4')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV2 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3DIV2 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV2 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute div(S) = (dS_xx/dx + dS_xy/dy, dS_xy/dx + dS_yy/dy)
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F4=SPP, DFDP=DPPDP, DFDQ=DPPDQ, &
                           G4=SQQ, DGDP=DQQDP, DGDQ=DQQDQ, &
                           H4=SPQ, DHDP=DPQDP, DHDQ=DPQDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DXXDX = DPPDP*DPDX(I1,I2) + DPPDQ*DQDX(I1,I2)
              DYYDY = DQQDP*DPDY(I1,I2) + DQQDQ*DQDY(I1,I2)
              DXYDX = DPQDP*DPDX(I1,I2) + DPQDQ*DQDX(I1,I2)
              DXYDY = DPQDP*DPDY(I1,I2) + DPQDQ*DQDY(I1,I2)
              DSX(I1,I2) = DXXDX + DXYDY
              DSY(I1,I2) = DXYDX + DYYDY
            END DO !I1
        END DO !I2

      END SUBROUTINE W3DIV2_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3DIV2_R8( NFD, IJG, ICLO, TILED, &
                            NP, NQ, LBI, UBI, LBO, UBO, &
                            DPDX, DPDY, DQDX, DQDY, &
                            SPP, SQQ, SPQ, DSX, DSY, MASK, RC )
!     Double precision interface
      INTEGER, INTENT(IN)   :: NFD
      LOGICAL, INTENT(IN)   :: IJG
      INTEGER, INTENT(IN)   :: ICLO
      LOGICAL, INTENT(IN)   :: TILED
      INTEGER, INTENT(IN)   :: NP, NQ
      INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
      INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
      REAL(8), INTENT(IN)   :: DPDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DPDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDX(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   :: DQDY(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::  SPP(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::  SQQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(IN)   ::  SPQ(LBI(1):UBI(1),LBI(2):UBI(2))
      REAL(8), INTENT(OUT)  ::  DSX(LBO(1):UBO(1),LBO(2):UBO(2))
      REAL(8), INTENT(OUT)  ::  DSY(LBO(1):UBO(1),LBO(2):UBO(2))
      LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
      INTEGER, INTENT(OUT), OPTIONAL :: RC

!     Local parameters
      INTEGER, PARAMETER :: M = 1 ! order of derivative
      INTEGER :: I1, I2, P, Q
      INTEGER :: ISTAT=0
      INTEGER :: K(0:NFD,0:NFD,1:NFD)
      REAL(8) :: C(0:NFD,0:NFD,1:NFD)
      REAL(8) :: DPPDP, DPPDQ, DQQDP, DQQDQ, DPQDP, DPQDQ
      REAL(8) :: DXXDX, DYYDY, DXYDX, DXYDY
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIV2_R8')
! -------------------------------------------------------------------- /
! 1.  Check and setup inputs
!
      IF ( PRESENT(RC) ) RC = 0

      IF ( NFD.LE.0 .OR. MOD(NFD,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV2 ERROR -- ', &
          'NFD must be even and greater than zero'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF

      SELECT CASE ( ICLO )
          CASE ( ICLO_NONE, ICLO_GRDI, ICLO_GRDJ, ICLO_TRDL, ICLO_TRPL )
            CONTINUE
          CASE DEFAULT
            WRITE(0,'(/1A,1A,1I2/)') 'W3DIV2 ERROR -- ', &
            'unsupported ICLO: ',ICLO
            ISTAT = 1
            IF ( PRESENT(RC) ) THEN
                RC = ISTAT
                RETURN
              ELSE
                CALL EXTCDE (ISTAT)
              END IF
        END SELECT

      IF ( ICLO.EQ.ICLO_TRPL .AND. MOD(NP,2).NE.0 ) THEN
          WRITE(0,'(/1A,1A/)') 'W3DIV2 ERROR -- ', &
          'tripole grid closure requires NP even'
          ISTAT = 1
          IF ( PRESENT(RC) ) THEN
              RC = ISTAT
              RETURN
            ELSE
              CALL EXTCDE (ISTAT)
            END IF
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Setup finite difference coefficients
!
      CALL GET_FDW3 ( NFD, M, K, C )
!
! -------------------------------------------------------------------- /
! 3.  Compute div(S) = (dS_xx/dx + dS_xy/dy, dS_xy/dx + dS_yy/dy)
!
      DO I2 = LBO(2), UBO(2)
          DO I1 = LBO(1), UBO(1)
              IF ( IJG ) THEN
                  P = I1
                  Q = I2
                ELSE
                  P = I2
                  Q = I1
                END IF
              CALL DFDPQ ( NFD, K, C, IJG, ICLO, TILED, &
                           NP, NQ, LBI, UBI, P, Q, &
                           F8=SPP, DFDP=DPPDP, DFDQ=DPPDQ, &
                           G8=SQQ, DGDP=DQQDP, DGDQ=DQQDQ, &
                           H8=SPQ, DHDP=DPQDP, DHDQ=DPQDQ, &
                           MASK=MASK, RC=ISTAT )
              IF ( ISTAT .NE. 0 ) THEN
                  IF ( PRESENT(RC) ) THEN
                      RC = ISTAT
                      RETURN
                    ELSE
                      CALL EXTCDE (ISTAT)
                    END IF
                END IF
              DXXDX = DPPDP*DPDX(I1,I2) + DPPDQ*DQDX(I1,I2)
              DYYDY = DQQDP*DPDY(I1,I2) + DQQDQ*DQDY(I1,I2)
              DXYDX = DPQDP*DPDX(I1,I2) + DPQDQ*DQDX(I1,I2)
              DXYDY = DPQDP*DPDY(I1,I2) + DPQDQ*DQDY(I1,I2)
              DSX(I1,I2) = DXXDX + DXYDY
              DSY(I1,I2) = DXYDX + DYYDY
            END DO !I1
        END DO !I2

      END SUBROUTINE W3DIV2_R8
!/
!/ End of W3DIV2 ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3DIST( LLG, XT, YT, XS, YS ) RESULT(DIST)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute distance between two points.  If spherical grid, then
!     distance is the angle (in degrees) between the two points.
!
!  2. Method :
!
!     Map Projections -- A Working Manual, John P. Snyder
!     U.S. Geological Survey professional paper; 1395
!     Chapter 5. Transformation of Map Graticules
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       DIST    Real   O   Distance
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       LLG     Log.   I   Logical flag indicating the coordinate system:
!                          T = spherical lat/lon (degrees) and F = Cartesian.
!       XT      Real   I   X-coordinate of target point.
!       YT      Real   I   Y-coordinate of target point.
!       XS      Real   I   X-coordinate of source point.
!       YS      Real   I   Y-coordinate of source point.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!     !/T8   Enables NaN check.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3DIST_R4( LLG, XT, YT, XS, YS ) RESULT(DIST)
!     Single precision interface
      REAL(4)             :: DIST
      LOGICAL, INTENT(IN) :: LLG
      REAL(4), INTENT(IN) :: XT, YT
      REAL(4), INTENT(IN) :: XS, YS

!     Local parameters
      REAL(8) :: XT8, YT8, XS8, YS8
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIST_R4')
!
!-----set inputs
      XT8 = XT; YT8 = YT;
      XS8 = XS; YS8 = YS;
!
!-----call double precision method
      DIST = W3DIST( LLG, XT8, YT8, XS8, YS8 )

      END FUNCTION W3DIST_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3DIST_R8( LLG, XT, YT, XS, YS ) RESULT(DIST)
!     Double precision interface
      REAL(8)             :: DIST
      LOGICAL, INTENT(IN) :: LLG
      REAL(8), INTENT(IN) :: XT, YT
      REAL(8), INTENT(IN) :: XS, YS

!     Local parameters
      REAL(8) :: DX, DY, SLAM, SPHI, ARGD
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3DIST_R8')
!
!-----compute displacements
      DX = XT - XS
      DY = YT - YS

      IF ( LLG ) THEN !spherical coordinates
!---------check for longitudinal branch cut crossing
          IF ( ABS(DX) .GT. D270 ) THEN
              DX = DX - SIGN(D360,DX)
            END IF
#ifdef DIST_WITH_SINE
!---------compute angular distance using sin(d/2)
!         (this equation is more accurate than cos(d))
          SLAM = SIN(HALF*DX*D2R)
          SPHI = SIN(HALF*DY*D2R)
          ARGD = SQRT( COS(YT*D2R)*COS(YS*D2R)*SLAM*SLAM + SPHI*SPHI )
          DIST = R2D*TWO*ASIN( ARGD )
#else
!---------compute angular distance using cos(c) (min required
!         for rare situation of acos(1+small) generating NaN)
          ARGD = MIN( ONE, COS(YT*D2R)*COS(YS*D2R)*COS(DX*D2R) &
                           + SIN(YT*D2R)*SIN(YS*D2R) )
          DIST = R2D*ACOS( ARGD )
#endif
        ELSE !cartesian coordinates
!---------compute cartesian distance
          DIST = SQRT( DX**2 + DY**2 )
        END IF !cartesian coordinates
!/T8      IF ( W3INAN(DIST) ) THEN
!/T8          WRITE(0,'(/1A/)') 'W3DIST_R8 ERROR -- result is NaN'
!/T8          CALL EXTCDE (1)
!/T8        END IF

      END FUNCTION W3DIST_R8
!/
!/ End of W3DIST ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3SPLX( LAM0, PHI0, C0, LAM, PHI, X, Y )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute Cartesian coordinates from input longitude and latitude
!     using stereographic projection with center at (LAM0,PHI0) and
!     "standard circle" of angular distance C0 (in degrees) from the
!     center.
!
!  2. Method :
!
!     Map Projections -- A Working Manual, John P. Snyder
!     U.S. Geological Survey professional paper; 1395
!     Chapter 21. Stereographic projection
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       LAM0    Real   I   Longitude of center of projection.
!       PHI0    Real   I   Latitude of center of projection.
!       C0      Real   I   Angular distance from center of projection
!                          where the scale factor is one.
!       LAM     Real   I   Longitude of input point.
!       PHI     Real   I   Latitude of input point.
!       X       Real   O   Cartesian x-coordinate of input point.
!       Y       Real   O   Cartesian y-coordinate of input point.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_0D_R4( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Single precision point interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: LAM, PHI
      REAL(4), INTENT(OUT):: X, Y

!     Local parameters
      REAL(8) :: K, K0, CLAM, SLAM, CPHI0, CPHI, SPHI0, SPHI
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_0D_R4')

      CLAM  = COS((LAM-LAM0)*D2R)
      SLAM  = SIN((LAM-LAM0)*D2R)
      CPHI0 = COS(PHI0*D2R)
      CPHI  = COS(PHI*D2R)
      SPHI0 = SIN(PHI0*D2R)
      SPHI  = SIN(PHI*D2R)
      K0    = COS(HALF*C0*D2R)**2
      K     = TWO*K0*REARTH/(ONE+SPHI0*SPHI+CPHI0*CPHI*CLAM)
      X     = K*CPHI*SLAM
      Y     = K*(CPHI0*SPHI-SPHI0*CPHI*CLAM)

      END SUBROUTINE W3SPLX_0D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_0D_R8( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Double precision point interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: LAM, PHI
      REAL(8), INTENT(OUT):: X, Y

!     Local parameters
      REAL(8) :: K, K0, CLAM, SLAM, CPHI0, CPHI, SPHI0, SPHI
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_0D_R8')

      CLAM  = COS((LAM-LAM0)*D2R)
      SLAM  = SIN((LAM-LAM0)*D2R)
      CPHI0 = COS(PHI0*D2R)
      CPHI  = COS(PHI*D2R)
      SPHI0 = SIN(PHI0*D2R)
      SPHI  = SIN(PHI*D2R)
      K0    = COS(HALF*C0*D2R)**2
      K     = TWO*K0*REARTH/(ONE+SPHI0*SPHI+CPHI0*CPHI*CLAM)
      X     = K*CPHI*SLAM
      Y     = K*(CPHI0*SPHI-SPHI0*CPHI*CLAM)

      END SUBROUTINE W3SPLX_0D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_1D_R4( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Single precision 1D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: LAM(:), PHI(:)
      REAL(4), INTENT(OUT):: X(:), Y(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_1D_R4')

      DO I = LBOUND(LAM,1),UBOUND(LAM,1)
          CALL W3SPLX( LAM0, PHI0, C0, LAM(I), PHI(I), X(I), Y(I) )
        ENDDO

      END SUBROUTINE W3SPLX_1D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_1D_R8( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Double precision 1D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: LAM(:), PHI(:)
      REAL(8), INTENT(OUT):: X(:), Y(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_1D_R8')

      DO I = LBOUND(LAM,1),UBOUND(LAM,1)
          CALL W3SPLX( LAM0, PHI0, C0, LAM(I), PHI(I), X(I), Y(I) )
        ENDDO

      END SUBROUTINE W3SPLX_1D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_2D_R4( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Single precision 2D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: LAM(:,:), PHI(:,:)
      REAL(4), INTENT(OUT):: X(:,:), Y(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_2D_R4')

      DO J = LBOUND(LAM,2),UBOUND(LAM,2)
      DO I = LBOUND(LAM,1),UBOUND(LAM,1)
          CALL W3SPLX( LAM0, PHI0, C0, LAM(I,J), PHI(I,J), X(I,J), Y(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3SPLX_2D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPLX_2D_R8( LAM0, PHI0, C0, LAM, PHI, X, Y )
!     Double precision 2D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: LAM(:,:), PHI(:,:)
      REAL(8), INTENT(OUT):: X(:,:), Y(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPLX_2D_R8')

      DO J = LBOUND(LAM,2),UBOUND(LAM,2)
      DO I = LBOUND(LAM,1),UBOUND(LAM,1)
          CALL W3SPLX( LAM0, PHI0, C0, LAM(I,J), PHI(I,J), X(I,J), Y(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3SPLX_2D_R8
!/
!/ End of W3SPLX ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3SPXL( LAM0, PHI0, X, Y, LAM, PHI )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute longitude and latitude coordinates from input Cartesian
!     coordinates using stereographic projection with center at (LAM0,PHI0)
!     and "standard circle" of angular distance C0 (in degrees) from the
!     center.
!
!  2. Method :
!
!     Map Projections -- A Working Manual, John P. Snyder
!     U.S. Geological Survey professional paper; 1395
!     Chapter 21. Stereographic projection
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       LAM0    Real   I   Longitude of center of projection.
!       PHI0    Real   I   Latitude of center of projection.
!       C0      Real   I   Angular distance from center of projection
!                          where the scale factor is one.
!       X       Real   I   Cartesian x-coordinate of input point.
!       Y       Real   I   Cartesian y-coordinate of input point.
!       LAM     Real   O   Longitude of input point.
!       PHI     Real   O   Latitude of input point.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_0D_R4( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Single precision point interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: X, Y
      REAL(4), INTENT(OUT):: LAM, PHI

!     Local parameters
      REAL(8) :: K0, RHO, C, COSC, SINC, CPHI0, SPHI0
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_0D_R4')

      K0    = COS(HALF*C0*D2R)**2
      RHO   = SQRT(X*X+Y*Y)
      C     = TWO*ATAN2(RHO,TWO*REARTH*K0)
      COSC  = COS(C)
      SINC  = SIN(C)
      CPHI0 = COS(PHI0*D2R)
      SPHI0 = SIN(PHI0*D2R)
      PHI   = ASIN(COSC*SPHI0+Y*SINC*CPHI0/RHO)*R2D
      LAM   = LAM0 + ATAN2(X*SINC,RHO*CPHI0*COSC-Y*SPHI0*SINC)*R2D

      END SUBROUTINE W3SPXL_0D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_0D_R8( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Double precision point interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: X, Y
      REAL(8), INTENT(OUT):: LAM, PHI

!     Local parameters
      REAL(8) :: K0, RHO, C, COSC, SINC, CPHI0, SPHI0
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_0D_R8')

      K0    = COS(HALF*C0*D2R)**2
      RHO   = SQRT(X*X+Y*Y)
      C     = TWO*ATAN2(RHO,TWO*REARTH*K0)
      COSC  = COS(C)
      SINC  = SIN(C)
      CPHI0 = COS(PHI0*D2R)
      SPHI0 = SIN(PHI0*D2R)
      PHI   = ASIN(COSC*SPHI0+Y*SINC*CPHI0/RHO)*R2D
      LAM   = LAM0 + ATAN2(X*SINC,RHO*CPHI0*COSC-Y*SPHI0*SINC)*R2D

      END SUBROUTINE W3SPXL_0D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_1D_R4( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Single precision 1D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: X(:), Y(:)
      REAL(4), INTENT(OUT):: LAM(:), PHI(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_1D_R4')

      DO I = LBOUND(X,1),UBOUND(X,1)
          CALL W3SPXL( LAM0, PHI0, C0, X(I), Y(I), LAM(I), PHI(I) )
        ENDDO

      END SUBROUTINE W3SPXL_1D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_1D_R8( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Double precision 1D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: X(:), Y(:)
      REAL(8), INTENT(OUT):: LAM(:), PHI(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_1D_R8')

      DO I = LBOUND(X,1),UBOUND(X,1)
          CALL W3SPXL( LAM0, PHI0, C0, X(I), Y(I), LAM(I), PHI(I) )
        ENDDO

      END SUBROUTINE W3SPXL_1D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_2D_R4( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Single precision 2D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0, C0
      REAL(4), INTENT(IN) :: X(:,:), Y(:,:)
      REAL(4), INTENT(OUT):: LAM(:,:), PHI(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_2D_R4')

      DO J = LBOUND(X,2),UBOUND(X,2)
      DO I = LBOUND(X,1),UBOUND(X,1)
          CALL W3SPXL( LAM0, PHI0, C0, X(I,J), Y(I,J), LAM(I,J), PHI(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3SPXL_2D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SPXL_2D_R8( LAM0, PHI0, C0, X, Y, LAM, PHI )
!     Double precision 2D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0, C0
      REAL(8), INTENT(IN) :: X(:,:), Y(:,:)
      REAL(8), INTENT(OUT):: LAM(:,:), PHI(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SPXL_2D_R8')

      DO J = LBOUND(X,2),UBOUND(X,2)
      DO I = LBOUND(X,1),UBOUND(X,1)
          CALL W3SPXL( LAM0, PHI0, C0, X(I,J), Y(I,J), LAM(I,J), PHI(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3SPXL_2D_R8
!/
!/ End of W3SPXL ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3TRLL( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute longitude and latitude for input coordinates in a
!     coordinate system with the North Pole placed at a latitude
!     PHI0 on a meridian LAM0 east of the central meridian.
!
!  2. Method :
!
!     Map Projections -- A Working Manual, John P. Snyder
!     U.S. Geological Survey professional paper; 1395
!     Chapter 5. Transformation of Map Graticules
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       LAM0    Real   I   Longitude of North Pole
!       PHI0    Real   I   Latitude of North Pole
!       LAM1    Real   I   Input Longitude
!       PHI1    Real   I   Input Latitude
!       LAM     Real   O   Transformed Longitude
!       PHI     Real   O   Transformed Latitude
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_0D_R4( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Single precision point interface
      REAL(4), INTENT(IN) :: LAM0, PHI0
      REAL(4), INTENT(IN) :: LAM1, PHI1
      REAL(4), INTENT(OUT):: LAM, PHI

!     Local parameters
      REAL(8) :: CLAM, SLAM, CALP, SALP, CPHI, SPHI
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_0D_R4')

      CLAM  = COS((LAM1-LAM0)*D2R)
      SLAM  = SIN((LAM1-LAM0)*D2R)
      CALP  = COS(PHI0*D2R)
      SALP  = SIN(PHI0*D2R)
      CPHI  = COS(PHI1*D2R)
      SPHI  = SIN(PHI1*D2R)
      LAM   = LAM0 + ATAN2(CPHI*SLAM,SALP*CPHI*CLAM+CALP*SPHI)*R2D
      PHI   = ASIN(SALP*SPHI-CALP*CPHI*CLAM)*R2D

      END SUBROUTINE W3TRLL_0D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_0D_R8( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Double precision point interface
      REAL(8), INTENT(IN) :: LAM0, PHI0
      REAL(8), INTENT(IN) :: LAM1, PHI1
      REAL(8), INTENT(OUT):: LAM, PHI

!     Local parameters
      REAL(8) :: CLAM, SLAM, CALP, SALP, CPHI, SPHI
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_0D_R8')

      CLAM  = COS((LAM1-LAM0)*D2R)
      SLAM  = SIN((LAM1-LAM0)*D2R)
      CALP  = COS(PHI0*D2R)
      SALP  = SIN(PHI0*D2R)
      CPHI  = COS(PHI1*D2R)
      SPHI  = SIN(PHI1*D2R)
      LAM   = LAM0 + ATAN2(CPHI*SLAM,SALP*CPHI*CLAM+CALP*SPHI)*R2D
      PHI   = ASIN(SALP*SPHI-CALP*CPHI*CLAM)*R2D

      END SUBROUTINE W3TRLL_0D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_1D_R4( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Single precision 1D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0
      REAL(4), INTENT(IN) :: LAM1(:), PHI1(:)
      REAL(4), INTENT(OUT):: LAM(:), PHI(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_1D_R4')

      DO I = LBOUND(LAM1,1),UBOUND(LAM1,1)
          CALL W3TRLL( LAM0, PHI0, LAM1(I), PHI1(I), LAM(I), PHI(I) )
        ENDDO

      END SUBROUTINE W3TRLL_1D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_1D_R8( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Double precision 1D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0
      REAL(8), INTENT(IN) :: LAM1(:), PHI1(:)
      REAL(8), INTENT(OUT):: LAM(:), PHI(:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_1D_R8')

      DO I = LBOUND(LAM1,1),UBOUND(LAM1,1)
          CALL W3TRLL( LAM0, PHI0, LAM1(I), PHI1(I), LAM(I), PHI(I) )
        ENDDO

      END SUBROUTINE W3TRLL_1D_R8
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_2D_R4( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Single precision 2D array interface
      REAL(4), INTENT(IN) :: LAM0, PHI0
      REAL(4), INTENT(IN) :: LAM1(:,:), PHI1(:,:)
      REAL(4), INTENT(OUT):: LAM(:,:), PHI(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_2D_R4')

      DO J = LBOUND(LAM1,2),UBOUND(LAM1,2)
      DO I = LBOUND(LAM1,1),UBOUND(LAM1,1)
          CALL W3TRLL( LAM0, PHI0, LAM1(I,J), PHI1(I,J), LAM(I,J), PHI(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3TRLL_2D_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3TRLL_2D_R8( LAM0, PHI0, LAM1, PHI1, LAM, PHI )
!     Double precision 2D array interface
      REAL(8), INTENT(IN) :: LAM0, PHI0
      REAL(8), INTENT(IN) :: LAM1(:,:), PHI1(:,:)
      REAL(8), INTENT(OUT):: LAM(:,:), PHI(:,:)

!     Local parameters
      INTEGER :: I, J
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3TRLL_2D_R8')

      DO J = LBOUND(LAM1,2),UBOUND(LAM1,2)
      DO I = LBOUND(LAM1,1),UBOUND(LAM1,1)
          CALL W3TRLL( LAM0, PHI0, LAM1(I,J), PHI1(I,J), LAM(I,J), PHI(I,J) )
        ENDDO
        ENDDO

      END SUBROUTINE W3TRLL_2D_R8
!/
!/ End of W3TRLL ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3LLAZ( LAM1, PHI1, LAM2, PHI2 ) RESULT(AZ)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute azimuth (Az) east of north which point (LAM2,PHI2) bears
!     to point (LAM1,PHI1).
!
!  2. Method :
!
!     Map Projections -- A Working Manual, John P. Snyder
!     U.S. Geological Survey professional paper; 1395
!     Chapter 5. Transformation of Map Graticules
!
!  3. Parameters :
!
!     Return parameter
!     ----------------------------------------------------------------
!       AZ      Real   O   Azimuth in degrees east of north
!     ----------------------------------------------------------------
!
!     Parameter list
!     ----------------------------------------------------------------
!       LAM1    Real   I   Longitude for point 1
!       PHI1    Real   I   Latitude for point 1
!       LAM2    Real   I   Longitude for point 2
!       PHI2    Real   I   Latitude for point 2
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3LLAZ_R4( LAM1, PHI1, LAM2, PHI2 ) RESULT(AZ)
!     Single precision interface
      REAL(4)            :: AZ
      REAL(4), INTENT(IN):: LAM1, PHI1
      REAL(4), INTENT(IN):: LAM2, PHI2

!     Local parameters
      REAL(8) :: CLAM, SLAM, CPH1, SPH1, CPH2, SPH2
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3LLAZ_R8')

      CLAM = COS((LAM2-LAM1)*D2R)
      SLAM = SIN((LAM2-LAM1)*D2R)
      CPH1 = COS(PHI1*D2R)
      SPH1 = SIN(PHI1*D2R)
      CPH2 = COS(PHI2*D2R)
      SPH2 = SIN(PHI2*D2R)
      AZ   = ATAN2(CPH2*SLAM,CPH1*SPH2-SPH1*CPH2*CLAM)*R2D

      END FUNCTION W3LLAZ_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3LLAZ_R8( LAM1, PHI1, LAM2, PHI2 ) RESULT(AZ)
!     Double precision interface
      REAL(8)            :: AZ
      REAL(8), INTENT(IN):: LAM1, PHI1
      REAL(8), INTENT(IN):: LAM2, PHI2

!     Local parameters
      REAL(8) :: CLAM, SLAM, CPH1, SPH1, CPH2, SPH2
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3LLAZ_R8')

      CLAM = COS((LAM2-LAM1)*D2R)
      SLAM = SIN((LAM2-LAM1)*D2R)
      CPH1 = COS(PHI1*D2R)
      SPH1 = SIN(PHI1*D2R)
      CPH2 = COS(PHI2*D2R)
      SPH2 = SIN(PHI2*D2R)
      AZ   = ATAN2(CPH2*SLAM,CPH1*SPH2-SPH1*CPH2*CLAM)*R2D

      END FUNCTION W3LLAZ_R8
!/
!/ End of W3LLAZ ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3FDWT( N, ND, M, Z, X, C )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Compute finite-difference weights on arbitrarily spaced
!     1-D node sets.
!
!  2. Method :
!
!     Fornberg, B., Calculation of weights in finite difference formulas,
!       SIAM Rev. 40:685-691, 1998.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       N       Int.   I   One less than total number of grid points;
!                          n must not exceed the parameter nd below.
!       ND      Int.   I   Dimension of X- and C-arrays in calling program
!                          X(0:ND) and C(0:ND,0:M), respectively.
!       M       Int.   I   Highest derivative for which weights are sought.
!       Z       Real   I   Location where approximations are to be accurate.
!       X       R.A.   I   Grid point locations, found in X(0:N)
!       C       R.A.   O   Weights at grid locations X(0:N) for derivatives
!                          of order 0:M, found in C(0:N,0:M)
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3FDWT_R4 ( N, ND, M, Z, X, C )
!     Single precision interface
      INTEGER, INTENT(IN)  :: N, ND, M 
      REAL(4), INTENT(IN)  :: Z
      REAL(4), INTENT(IN)  :: X(0:ND)
      REAL(4), INTENT(OUT) :: C(0:ND,0:M)

!     Local parameters
      INTEGER :: I, J, K, MN
      REAL(8) :: C1, C2, C3, C4, C5
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3FDWT_R4')

      C1 = ONE
      C4 = X(0)-Z
      C(:,:) = ZERO
      C(0,0) = ONE
      ILOOP: DO I = 1,N
          MN = MIN(I,M)
          C2 = ONE
          C5 = C4
          C4 = X(I)-Z
          JLOOP: DO J = 0,I-1
              C3 = X(I)-X(J)
              C2 = C2*C3
              IF ( J.EQ.I-1 ) THEN
                  DO K = MN,1,-1
                      C(I,K) = C1*(K*C(I-1,K-1)-C5*C(I-1,K))/C2
                    END DO
                  C(I,0) = -C1*C5*C(I-1,0)/C2
                END IF
              DO K = MN,1,-1
                  C(J,K) = (C4*C(J,K)-K*C(J,K-1))/C3
                END DO
              C(J,0) = C4*C(J,0)/C3
            END DO JLOOP
            C1 = C2
        END DO ILOOP

      END SUBROUTINE W3FDWT_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3FDWT_R8 ( N, ND, M, Z, X, C )
!     Double precision interface
      INTEGER, INTENT(IN)  :: N, ND, M 
      REAL(8), INTENT(IN)  :: Z
      REAL(8), INTENT(IN)  :: X(0:ND)
      REAL(8), INTENT(OUT) :: C(0:ND,0:M)

!     Local parameters
      INTEGER :: I, J, K, MN
      REAL(8) :: C1, C2, C3, C4, C5
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3FDWT_R4')

      C1 = ONE
      C4 = X(0)-Z
      C(:,:) = ZERO
      C(0,0) = ONE
      ILOOP: DO I = 1,N
          MN = MIN(I,M)
          C2 = ONE
          C5 = C4
          C4 = X(I)-Z
          JLOOP: DO J = 0,I-1
              C3 = X(I)-X(J)
              C2 = C2*C3
              IF ( J.EQ.I-1 ) THEN
                  DO K = MN,1,-1
                      C(I,K) = C1*(K*C(I-1,K-1)-C5*C(I-1,K))/C2
                    END DO
                  C(I,0) = -C1*C5*C(I-1,0)/C2
                END IF
              DO K = MN,1,-1
                  C(J,K) = (C4*C(J,K)-K*C(J,K-1))/C3
                END DO
              C(J,0) = C4*C(J,0)/C3
            END DO JLOOP
            C1 = C2
        END DO ILOOP

      END SUBROUTINE W3FDWT_R8
!/
!/ End of W3FDWT ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3NNSC( NLVL ) RESULT(NNS)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Create nearest-neighbor (NNBR) search object.
!
!  2. Method :
!
!     Notation
!     ( L,  N):  L = NNBR level;  N = NNBR sequential index
!     {DI, DJ}:  DI = I-index delta;  DJ = J-index delta
!
!     ---------------------------------------------------
!     | ( 2,21) | ( 2,20) | ( 2,19) | ( 2,18) | ( 2,17) |
!     | {-2,+2} | {-1,+2} | { 0,+2} | {+1,+2} | {+2,+2} |
!     ---------------------------------------------------
!     | ( 2,22) | ( 1, 7) | ( 1, 6) | ( 1, 5) | ( 2,16) |
!     | {-2,+1} | {-1,+1} | { 0,+1} | {+1,+1} | {+2,+1} |
!     ---------------------------------------------------
!     | ( 2,23) | ( 1, 8) | ( 0, 0) | ( 1, 4) | ( 2,15) |
!     | {-2, 0} | {-1, 0} | { 0, 0} | {+1, 0} | {+2, 0} |
!     ---------------------------------------------------
!     | ( 2,24) | ( 1, 1) | ( 1, 2) | ( 1, 3) | ( 2,14) |
!     | {-2,-1} | {-1,-1} | { 0,-1} | {+1,-1} | {+2,-1} |
!     ---------------------------------------------------
!     | ( 2, 9) | ( 2,10) | ( 2,11) | ( 2,12) | ( 2,13) |
!     | {-2,-2} | {-1,-2} | { 0,-2} | {+1,-2} | {+2,-2} |
!     ---------------------------------------------------
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3NNSC( NLVL ) RESULT(NNS)
      TYPE(T_NNS), POINTER :: NNS
      INTEGER, INTENT(IN)  :: NLVL

!     Local parameters
      INTEGER :: I, J, K, L, N
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3NNSC')
!
!-----allocate object
      ALLOCATE(NNS)

!-----initialize sizes
      NNS%NLVL = NLVL
      NNS%NNBR = (2*NLVL+1)**2

!-----allocate arrays
      ALLOCATE(NNS%N1(0:NNS%NLVL))
      ALLOCATE(NNS%N2(0:NNS%NLVL))
      ALLOCATE(NNS%DI(0:NNS%NNBR-1))
      ALLOCATE(NNS%DJ(0:NNS%NNBR-1))

!-----compute index deltas for nearest-neighbor searches
      N = 0
!-----central point
      L = 0
      NNS%N1(L) = 0;  NNS%N2(L) = (2*L+1)**2-1;
      NNS%DI(N) = 0;  NNS%DJ(N) = 0;
!-----loop over levels
      DO L=1,NNS%NLVL
!---------nnbr loop bounds
          NNS%N1(L) = (2*L-1)**2;  NNS%N2(L) = (2*L+1)**2-1;
!---------bottom-layer
          J = -L
          DO I=-L,L-1
              N = N + 1
              NNS%DI(N) = I;  NNS%DJ(N) = J;
            END DO
!---------right-layer
          I =  L
          DO J=-L,L-1
              N = N + 1
              NNS%DI(N) = I;  NNS%DJ(N) = J;
            END DO
!---------top-layer
          J =  L
          DO I=L,-L+1,-1
              N = N + 1
              NNS%DI(N) = I;  NNS%DJ(N) = J;
            END DO
!---------left-layer
          I = -L
          DO J=L,-L+1,-1
              N = N + 1
              NNS%DI(N) = I;  NNS%DJ(N) = J;
            END DO
        END DO !loop over levels

      END FUNCTION W3NNSC
!/
!/ End of W3NNSC ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3NNSD( NNS )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Destroy nearest-neighbor (NNBR) search object.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3NNSD( NNS )
      TYPE(T_NNS), POINTER :: NNS

!     Local parameters
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3NNSD')
!
      IF ( ASSOCIATED(NNS) ) THEN
          NNS%NLVL = 0
          NNS%NNBR = 0
          IF ( ASSOCIATED(NNS%N1) ) THEN
              DEALLOCATE(NNS%N1);  NULLIFY(NNS%N1);
            END IF
          IF ( ASSOCIATED(NNS%N2) ) THEN
              DEALLOCATE(NNS%N2);  NULLIFY(NNS%N2);
            END IF
          IF ( ASSOCIATED(NNS%DI) ) THEN
              DEALLOCATE(NNS%DI);  NULLIFY(NNS%DI);
            END IF
          IF ( ASSOCIATED(NNS%DJ) ) THEN
              DEALLOCATE(NNS%DJ);  NULLIFY(NNS%DJ);
            END IF
          DEALLOCATE(NNS)
          NULLIFY(NNS)
        END IF

      END SUBROUTINE W3NNSD
!/
!/ End of W3NNSD ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3NNSP( NNS, IUNIT )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Print nearest-neighbor (NNBR) search object to IUNIT.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NNBR    Type   I   Nearest-neighbor search object.
!       IUNIT   Int.   I   OPTIONAL unit for output. Default is stdout.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3NNSP(NNS, IUNIT)
      TYPE(T_NNS), INTENT(IN) :: NNS
      INTEGER, OPTIONAL, INTENT(IN) :: IUNIT

!     Local parameters
      INTEGER :: NDST, K, L, N
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3NNSP')
!
      IF ( PRESENT(IUNIT) ) THEN
          NDST = IUNIT
        ELSE
          NDST = 6
        END IF
!
      WRITE(NDST,'(A,2I6)') 'nlvl,nnbr:',NNS%NLVL,NNS%NNBR
      DO L=0,NNS%NLVL
          DO N=NNS%N1(L),NNS%N2(L)
              WRITE(NDST,'(A,4I6)') 'l,n,di,dj:',L,N,NNS%DI(N),NNS%DJ(N)
            END DO
        END DO

      END SUBROUTINE W3NNSP
!/
!/ End of W3NNSP ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3SORT( N, I, J, D )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Sort input arrays in increasing order according to input array D.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SORT_R4( N, I, J, D )
!     Single precision interface.
      INTEGER, INTENT(IN)    :: N
      INTEGER, INTENT(INOUT) :: I(N)
      INTEGER, INTENT(INOUT) :: J(N)
      REAL(4), INTENT(INOUT) :: D(N)

!     Local parameters
      INTEGER :: K, L, IM, JM
      REAL(4) :: DM
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SORT_R4')

      DO K=1, N-1
          DO L=K+1, N
              IF ( D(L) .LT. D(K) ) THEN
                  IM = I(K);  JM = J(K);  DM = D(K);
                  I(K) = I(L);  J(K) = J(L);  D(K) = D(L);
                  I(L) = IM;  J(L) = JM;  D(L) = DM;
                END IF
            END DO !L
        END DO !K

      END SUBROUTINE W3SORT_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3SORT_R8( N, I, J, D )
!     Double precision interface.
      INTEGER, INTENT(IN)    :: N
      INTEGER, INTENT(INOUT) :: I(N)
      INTEGER, INTENT(INOUT) :: J(N)
      REAL(8), INTENT(INOUT) :: D(N)

!     Local parameters
      INTEGER :: K, L, IM, JM
      REAL(8) :: DM
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3SORT_R8')

      DO K=1, N-1
          DO L=K+1, N
              IF ( D(L) .LT. D(K) ) THEN
                  IM = I(K);  JM = J(K);  DM = D(K);
                  I(K) = I(L);  J(K) = J(L);  D(K) = D(L);
                  I(L) = IM;  J(L) = JM;  D(L) = DM;
                END IF
            END DO !L
        END DO !K

      END SUBROUTINE W3SORT_R8
!/
!/ End of W3SORT ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    SUBROUTINE W3ISRT( II, JJ, DD, N, I, J, D )
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Insert DD data into D at location where DD < D(K).
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3ISRT_R4( II, JJ, DD, N, I, J, D )
!     Single precision interface
      INTEGER, INTENT(IN)    :: II
      INTEGER, INTENT(IN)    :: JJ
      REAL(4), INTENT(IN)    :: DD
      INTEGER, INTENT(IN)    :: N
      INTEGER, INTENT(INOUT) :: I(N)
      INTEGER, INTENT(INOUT) :: J(N)
      REAL(4), INTENT(INOUT) :: D(N)

!     Local parameters
      INTEGER :: K, L
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3ISRT_R4')

      K_LOOP: DO K=1,N
          IF ( DD .LT. D(K) ) THEN
!---------right-shift list (>= k)
              DO L=N,K+1,-1
                  I(L) = I(L-1);  J(L) = J(L-1);  D(L) = D(L-1);
                END DO !L
!---------insert point into list at k
              I(K) = II;  J(K) = JJ;  D(K) = DD;
              EXIT K_LOOP
            END IF !dd.lt.d(k)
        END DO K_LOOP

      END SUBROUTINE W3ISRT_R4
!/
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE W3ISRT_R8( II, JJ, DD, N, I, J, D )
!     Double precision interface
      INTEGER, INTENT(IN)    :: II
      INTEGER, INTENT(IN)    :: JJ
      REAL(8), INTENT(IN)    :: DD
      INTEGER, INTENT(IN)    :: N
      INTEGER, INTENT(INOUT) :: I(N)
      INTEGER, INTENT(INOUT) :: J(N)
      REAL(8), INTENT(INOUT) :: D(N)

!     Local parameters
      INTEGER :: K, L
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3ISRT_R8')

      K_LOOP: DO K=1,N
          IF ( DD .LT. D(K) ) THEN
!---------right-shift list (>= k)
              DO L=N,K+1,-1
                  I(L) = I(L-1);  J(L) = J(L-1);  D(L) = D(L-1);
                END DO !L
!---------insert point into list at k
              I(K) = II;  J(K) = JJ;  D(K) = DD;
              EXIT K_LOOP
            END IF !dd.lt.d(k)
        END DO K_LOOP

      END SUBROUTINE W3ISRT_R8
!/
!/ End of W3ISRT ===================================================== /
!/




!/
!/ =================================================================== /
!/
!/    FUNCTION W3INAN( X ) RESULT(INAN)
!/
!/ =================================================================== /
!/
!  1. Purpose :
!
!     Return TRUE if input is infinite or NaN (not a number).
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!
! 10. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3INAN_R4( X ) RESULT(INAN)
!     Single precision interface
      LOGICAL             :: INAN
      REAL(4), INTENT(IN) :: X

!     Local parameters
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3INAN_R4')

!-----return true if X is NaN or +Inf or -Inf
      INAN = .NOT. ( X .GE. -HUGE(X) .AND. X .LE. HUGE(X) )

      END FUNCTION W3INAN_R4
!/
!/ ------------------------------------------------------------------- /
!/
      FUNCTION W3INAN_R8( X ) RESULT(INAN)
!     Double precision interface
      LOGICAL             :: INAN
      REAL(8), INTENT(IN) :: X

!     Local parameters
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'W3INAN_R8')

!-----return true if X is NaN or +Inf or -Inf
      INAN = .NOT. ( X .GE. -HUGE(X) .AND. X .LE. HUGE(X) )

      END FUNCTION W3INAN_R8
!/
!/ End of W3INAN ===================================================== /
!/


      SUBROUTINE EXTCDE(IEXIT)
#ifdef ENABLE_MPI
      INCLUDE "mpif.h"
#endif
      INTEGER, INTENT(IN) :: IEXIT
#ifdef ENABLE_MPI
      INTEGER             :: IERR_MPI
      LOGICAL             :: RUN
      CALL MPI_INITIALIZED ( RUN, IERR_MPI )
      IF ( RUN ) THEN
          CALL MPI_ABORT ( MPI_COMM_WORLD, IEXIT, IERR_MPI )
        END IF
#endif
      CALL EXIT(IEXIT)
      END SUBROUTINE EXTCDE


!/
!/ End of module W3GSRUMD ============================================ /
!/
      END MODULE COAMPS_GSRUMD
