README for ATM-OCN Select External NUOPC prototype
--------------------------------------------------

Dependencies: 
  - ESMF v.6.2.0
  
Build:
  - Set environment variable ESMFMKFILE to point to the esmf.mk of your ESMF
    installation.
  - gmake
  
Execution:
  - Optionally set environment variable ESMF_RUNTIME_COMPLIANCECHECK to ON.
  - mpirun -np X ./esmApp (where X is the total number of PETs)
  
Output:
  - PET*.Log files containing compliance checker output if turned on.
  - The prototype outputs time stepping information to stdout.
  
Code structure:
  - Makefile    - Makefile that is based on the standard esmf.mk mechanism.
  - esm.F90     - The Earth System Model (ESM) component, specializing generic
                  NUOPC_DriverAtmOcn
  - esmApp.F90  - ESM driver application.
  - esm.config  - ESMF configuration
  --> ATM-A     - subdirectory containing an external ATM model
  --> ATM-B     - subdirectory containing another external ATM model
  --> OcnModelA - subdirectory containing an external OCN model
  --> OcnModelB - subdirectory containing another external OCN model

Explanation:

    This prototype code demonstrates the recommended way of how to implement
  external component dependencies in NUOPC based application code.  At the same
  time selection between alternative component options is shown on the driver
  level.
  
    The term "external components" means that a component is build from source
  outside of the build procedure of the code that actually uses the component.
  The same component object file could be used by multiple applications.
  The external nature of a component is only visible on the build level,
  and does not affect how the component is used from within the calling code.  
  The build level uses GNU makefile fragments to handle external component
  dependencies.
  
  Within each external component subdirectory a Makefile exisits that locally
  builds the component object file, but also produces a file with the extension
  ".mk".  This is a makefile fragment that contains all the necessary 
  information needed to compile and link against the external component.  The
  Makefile of the main application that uses an external component includes the
  makefile fragment and uses the defined variables to express the build rules
  for the depending local source files.
  
    The component selection mechanism inside the driver code is unaffected by
  the fact that some or all components are provided externally.  Two basic 
  selection mechanisms exist:
  1) compile-time selection, e.g. via pre-processor macros
  2) run-time selection, e.g. via configuration file attribute
  Both mechanisms are supported, and can be mixed.
    
    Here the esm.F90 code is where the selection occurs between atmA and atmB,
  as well as between ocnA and ocnB. 
  
  * Selection between atmA and atmB is purely a compile-time selection based
    on a macros. The code switches the atmSS association according to macros
    WITH_ATM_A and WITH_ATM_B. The preprocessor conditionals used ensure that
    these two options are mutually execlusive, and that exactly one of these
    options is provided, or else the code will bail out during compilation.
    
  * Selection between ocnA and ocnB is a combined compile-time and run-time based
    selection. During build time the macros WITH_OCN_A and WITH_OCN_B determine
    which options will be available during run-time. Then during run-time an
    attribute is read from a configuration file and the actual selection between
    ocnA and ocnB is made. An error code is issued if the selection is not 
    available at run-time, e.g. because it was not built into the code during
    compile-time.
    
  * The Makefile contains code that sets the WITH_ATM_A, WITH_ATM_B, WITH_OCN_A,
    and WITH_OCN_B macros by analyzing the ATM and OCN variables passed into 
    make. So for instance building with "gmake ATM=A OCN=A,B" will build an
    executable that has ATM-A, OCN-A and OCN-B compiled in.

    This prototype code demonstrates that there is generally no need for 
  component wrappers or stubs in codes that use the NUOPC Layer. Instead the
  flexibility to select actual component instantiation either during 
  compile-time and/or run-time is best implemented using standard constructs
  within the driver layer. The prototype shows a robust implementation that
  catches configuration conflicts at the earliest stage.
